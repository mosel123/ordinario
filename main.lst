CCS PCH C Compiler, Version 5.012, 41559               28-jun.-19 13:55

               Filename:   C:\Users\Usuario\Desktop\ordi\nombre\main.lst

               ROM used:   3008 bytes (5%)
                           Largest free fragment is 62524
               RAM used:   73 (2%) at main() level
                           110 (3%) worst case
               Stack used: 3 locations (2 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   090E
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  FF2.5
0004A:  GOTO   0054
0004E:  BTFSC  FF2.2
00050:  GOTO   010E
00054:  BTFSS  F9D.5
00056:  GOTO   0060
0005A:  BTFSC  F9E.5
0005C:  GOTO   00A2
00060:  MOVFF  0E,00
00064:  MOVFF  0F,01
00068:  MOVFF  10,02
0006C:  MOVFF  11,03
00070:  MOVFF  0C,FE9
00074:  MOVFF  07,FEA
00078:  BSF    07.7
0007A:  MOVFF  08,FE1
0007E:  MOVFF  09,FE2
00082:  MOVFF  0A,FD9
00086:  MOVFF  0B,FDA
0008A:  MOVFF  12,FF3
0008E:  MOVFF  13,FF4
00092:  MOVFF  14,FFA
00096:  MOVF   04,W
00098:  MOVFF  06,FE0
0009C:  MOVFF  05,FD8
000A0:  RETFIE 0
.................... #include <18f4620.h> 
.................... ///////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
*
0011E:  DATA 49,6E
00120:  DATA 67,72
00122:  DATA 65,73
00124:  DATA 61,20
00126:  DATA 6C,6F
00128:  DATA 73,20
0012A:  DATA 64,61
0012C:  DATA 74,6F
0012E:  DATA 73,20
00130:  DATA 64,65
00132:  DATA 20,6C
00134:  DATA 61,20
00136:  DATA 6D,61
00138:  DATA 6E,65
0013A:  DATA 72,61
0013C:  DATA 3A,20
0013E:  DATA 3E,6F
00140:  DATA 70,31
00142:  DATA 3B,6F
00144:  DATA 70,32
00146:  DATA 3B,6F
00148:  DATA 70,33
0014A:  DATA 3B,63
0014C:  DATA 61,72
0014E:  DATA 61,63
00150:  DATA 74,65
00152:  DATA 72,3C
00154:  DATA 00,00
00156:  DATA 0A,20
00158:  DATA 0D,00
0015A:  DATA 45,72
0015C:  DATA 72,6F
0015E:  DATA 72,20
00160:  DATA 72,65
00162:  DATA 69,6E
00164:  DATA 67,72
00166:  DATA 65,73
00168:  DATA 61,20
0016A:  DATA 63,6F
0016C:  DATA 72,72
0016E:  DATA 65,63
00170:  DATA 74,61
00172:  DATA 6D,65
00174:  DATA 6E,74
00176:  DATA 65,20
00178:  DATA 6C,6F
0017A:  DATA 73,20
0017C:  DATA 64,61
0017E:  DATA 74,6F
00180:  DATA 73,2E
00182:  DATA 2E,2E
00184:  DATA 00,00
00186:  DATA 0A,20
00188:  DATA 0D,00
0018A:  TBLRD*+
0018C:  MOVF   FF5,F
0018E:  BZ    01AA
00190:  MOVFF  FF6,49
00194:  MOVFF  FF7,4A
00198:  MOVF   FF5,W
0019A:  BTFSS  F9E.4
0019C:  BRA    019A
0019E:  MOVWF  FAD
001A0:  MOVFF  49,FF6
001A4:  MOVFF  4A,FF7
001A8:  BRA    018A
001AA:  RETURN 0
*
001B6:  MOVF   58,W
001B8:  BTFSC  FD8.2
001BA:  BRA    029E
001BC:  MOVWF  00
001BE:  MOVF   5C,W
001C0:  BTFSC  FD8.2
001C2:  BRA    029E
001C4:  ADDWF  00,F
001C6:  BNC   01D0
001C8:  MOVLW  81
001CA:  ADDWF  00,F
001CC:  BC    029E
001CE:  BRA    01D8
001D0:  MOVLW  7F
001D2:  SUBWF  00,F
001D4:  BNC   029E
001D6:  BZ    029E
001D8:  MOVFF  59,60
001DC:  MOVF   5D,W
001DE:  XORWF  60,F
001E0:  BSF    59.7
001E2:  BSF    5D.7
001E4:  MOVF   5B,W
001E6:  MULWF  5F
001E8:  MOVFF  FF4,62
001EC:  MOVF   5A,W
001EE:  MULWF  5E
001F0:  MOVFF  FF4,03
001F4:  MOVFF  FF3,61
001F8:  MULWF  5F
001FA:  MOVF   FF3,W
001FC:  ADDWF  62,F
001FE:  MOVF   FF4,W
00200:  ADDWFC 61,F
00202:  MOVLW  00
00204:  ADDWFC 03,F
00206:  MOVF   5B,W
00208:  MULWF  5E
0020A:  MOVF   FF3,W
0020C:  ADDWF  62,F
0020E:  MOVF   FF4,W
00210:  ADDWFC 61,F
00212:  MOVLW  00
00214:  CLRF   02
00216:  ADDWFC 03,F
00218:  ADDWFC 02,F
0021A:  MOVF   59,W
0021C:  MULWF  5F
0021E:  MOVF   FF3,W
00220:  ADDWF  61,F
00222:  MOVF   FF4,W
00224:  ADDWFC 03,F
00226:  MOVLW  00
00228:  ADDWFC 02,F
0022A:  MOVF   59,W
0022C:  MULWF  5E
0022E:  MOVF   FF3,W
00230:  ADDWF  03,F
00232:  MOVF   FF4,W
00234:  ADDWFC 02,F
00236:  MOVLW  00
00238:  CLRF   01
0023A:  ADDWFC 01,F
0023C:  MOVF   5B,W
0023E:  MULWF  5D
00240:  MOVF   FF3,W
00242:  ADDWF  61,F
00244:  MOVF   FF4,W
00246:  ADDWFC 03,F
00248:  MOVLW  00
0024A:  ADDWFC 02,F
0024C:  ADDWFC 01,F
0024E:  MOVF   5A,W
00250:  MULWF  5D
00252:  MOVF   FF3,W
00254:  ADDWF  03,F
00256:  MOVF   FF4,W
00258:  ADDWFC 02,F
0025A:  MOVLW  00
0025C:  ADDWFC 01,F
0025E:  MOVF   59,W
00260:  MULWF  5D
00262:  MOVF   FF3,W
00264:  ADDWF  02,F
00266:  MOVF   FF4,W
00268:  ADDWFC 01,F
0026A:  INCF   00,F
0026C:  BTFSC  01.7
0026E:  BRA    027A
00270:  RLCF   61,F
00272:  RLCF   03,F
00274:  RLCF   02,F
00276:  RLCF   01,F
00278:  DECF   00,F
0027A:  MOVLW  00
0027C:  BTFSS  61.7
0027E:  BRA    0294
00280:  INCF   03,F
00282:  ADDWFC 02,F
00284:  ADDWFC 01,F
00286:  MOVF   01,W
00288:  BNZ   0294
0028A:  MOVF   02,W
0028C:  BNZ   0294
0028E:  MOVF   03,W
00290:  BNZ   0294
00292:  INCF   00,F
00294:  BTFSC  60.7
00296:  BSF    01.7
00298:  BTFSS  60.7
0029A:  BCF    01.7
0029C:  BRA    02A6
0029E:  CLRF   00
002A0:  CLRF   01
002A2:  CLRF   02
002A4:  CLRF   03
002A6:  RETURN 0
002A8:  MOVLW  8E
002AA:  MOVWF  00
002AC:  MOVFF  5D,01
002B0:  MOVFF  5C,02
002B4:  CLRF   03
002B6:  MOVF   01,F
002B8:  BNZ   02CC
002BA:  MOVFF  02,01
002BE:  CLRF   02
002C0:  MOVLW  08
002C2:  SUBWF  00,F
002C4:  MOVF   01,F
002C6:  BNZ   02CC
002C8:  CLRF   00
002CA:  BRA    02DC
002CC:  BCF    FD8.0
002CE:  BTFSC  01.7
002D0:  BRA    02DA
002D2:  RLCF   02,F
002D4:  RLCF   01,F
002D6:  DECF   00,F
002D8:  BRA    02CC
002DA:  BCF    01.7
002DC:  RETURN 0
002DE:  MOVF   5C,W
002E0:  BTFSC  FD8.2
002E2:  BRA    042E
002E4:  MOVWF  68
002E6:  MOVF   60,W
002E8:  BTFSC  FD8.2
002EA:  BRA    042E
002EC:  SUBWF  68,F
002EE:  BNC   02FA
002F0:  MOVLW  7F
002F2:  ADDWF  68,F
002F4:  BTFSC  FD8.0
002F6:  BRA    042E
002F8:  BRA    0306
002FA:  MOVLW  81
002FC:  SUBWF  68,F
002FE:  BTFSS  FD8.0
00300:  BRA    042E
00302:  BTFSC  FD8.2
00304:  BRA    042E
00306:  MOVFF  68,00
0030A:  CLRF   01
0030C:  CLRF   02
0030E:  CLRF   03
00310:  CLRF   67
00312:  MOVFF  5D,66
00316:  BSF    66.7
00318:  MOVFF  5E,65
0031C:  MOVFF  5F,64
00320:  MOVLW  19
00322:  MOVWF  68
00324:  MOVF   63,W
00326:  SUBWF  64,F
00328:  BC    0344
0032A:  MOVLW  01
0032C:  SUBWF  65,F
0032E:  BC    0344
00330:  SUBWF  66,F
00332:  BC    0344
00334:  SUBWF  67,F
00336:  BC    0344
00338:  INCF   67,F
0033A:  INCF   66,F
0033C:  INCF   65,F
0033E:  MOVF   63,W
00340:  ADDWF  64,F
00342:  BRA    0394
00344:  MOVF   62,W
00346:  SUBWF  65,F
00348:  BC    036E
0034A:  MOVLW  01
0034C:  SUBWF  66,F
0034E:  BC    036E
00350:  SUBWF  67,F
00352:  BC    036E
00354:  INCF   67,F
00356:  INCF   66,F
00358:  MOVF   62,W
0035A:  ADDWF  65,F
0035C:  MOVF   63,W
0035E:  ADDWF  64,F
00360:  BNC   0394
00362:  INCF   65,F
00364:  BNZ   0394
00366:  INCF   66,F
00368:  BNZ   0394
0036A:  INCF   67,F
0036C:  BRA    0394
0036E:  MOVF   61,W
00370:  IORLW  80
00372:  SUBWF  66,F
00374:  BC    0392
00376:  MOVLW  01
00378:  SUBWF  67,F
0037A:  BC    0392
0037C:  INCF   67,F
0037E:  MOVF   61,W
00380:  IORLW  80
00382:  ADDWF  66,F
00384:  MOVF   62,W
00386:  ADDWF  65,F
00388:  BNC   035C
0038A:  INCF   66,F
0038C:  BNZ   035C
0038E:  INCF   67,F
00390:  BRA    035C
00392:  BSF    03.0
00394:  DECFSZ 68,F
00396:  BRA    039A
00398:  BRA    03B0
0039A:  BCF    FD8.0
0039C:  RLCF   64,F
0039E:  RLCF   65,F
003A0:  RLCF   66,F
003A2:  RLCF   67,F
003A4:  BCF    FD8.0
003A6:  RLCF   03,F
003A8:  RLCF   02,F
003AA:  RLCF   01,F
003AC:  RLCF   69,F
003AE:  BRA    0324
003B0:  BTFSS  69.0
003B2:  BRA    03C0
003B4:  BCF    FD8.0
003B6:  RRCF   01,F
003B8:  RRCF   02,F
003BA:  RRCF   03,F
003BC:  RRCF   69,F
003BE:  BRA    03C4
003C0:  DECF   00,F
003C2:  BZ    042E
003C4:  BTFSC  69.7
003C6:  BRA    0404
003C8:  BCF    FD8.0
003CA:  RLCF   64,F
003CC:  RLCF   65,F
003CE:  RLCF   66,F
003D0:  RLCF   67,F
003D2:  MOVF   63,W
003D4:  SUBWF  64,F
003D6:  BC    03E6
003D8:  MOVLW  01
003DA:  SUBWF  65,F
003DC:  BC    03E6
003DE:  SUBWF  66,F
003E0:  BC    03E6
003E2:  SUBWF  67,F
003E4:  BNC   041A
003E6:  MOVF   62,W
003E8:  SUBWF  65,F
003EA:  BC    03F6
003EC:  MOVLW  01
003EE:  SUBWF  66,F
003F0:  BC    03F6
003F2:  SUBWF  67,F
003F4:  BNC   041A
003F6:  MOVF   61,W
003F8:  IORLW  80
003FA:  SUBWF  66,F
003FC:  BC    0404
003FE:  MOVLW  01
00400:  SUBWF  67,F
00402:  BNC   041A
00404:  INCF   03,F
00406:  BNZ   041A
00408:  INCF   02,F
0040A:  BNZ   041A
0040C:  INCF   01,F
0040E:  BNZ   041A
00410:  INCF   00,F
00412:  BZ    042E
00414:  RRCF   01,F
00416:  RRCF   02,F
00418:  RRCF   03,F
0041A:  MOVFF  5D,68
0041E:  MOVF   61,W
00420:  XORWF  68,F
00422:  BTFSS  68.7
00424:  BRA    042A
00426:  BSF    01.7
00428:  BRA    0436
0042A:  BCF    01.7
0042C:  BRA    0436
0042E:  CLRF   00
00430:  CLRF   01
00432:  CLRF   02
00434:  CLRF   03
00436:  GOTO   07A0 (RETURN)
0043A:  MOVLW  80
0043C:  BTFSC  FD8.1
0043E:  XORWF  61,F
00440:  CLRF   66
00442:  CLRF   67
00444:  MOVFF  5D,65
00448:  MOVF   61,W
0044A:  XORWF  65,F
0044C:  MOVF   5C,W
0044E:  BTFSC  FD8.2
00450:  BRA    060A
00452:  MOVWF  64
00454:  MOVWF  00
00456:  MOVF   60,W
00458:  BTFSC  FD8.2
0045A:  BRA    061C
0045C:  SUBWF  64,F
0045E:  BTFSC  FD8.2
00460:  BRA    0564
00462:  BNC   04DE
00464:  MOVFF  61,6A
00468:  BSF    6A.7
0046A:  MOVFF  62,69
0046E:  MOVFF  63,68
00472:  CLRF   67
00474:  BCF    FD8.0
00476:  RRCF   6A,F
00478:  RRCF   69,F
0047A:  RRCF   68,F
0047C:  RRCF   67,F
0047E:  DECFSZ 64,F
00480:  BRA    0472
00482:  BTFSS  65.7
00484:  BRA    048C
00486:  BSF    66.0
00488:  BRA    0644
0048A:  BCF    66.0
0048C:  BCF    64.0
0048E:  BSF    66.4
00490:  CLRF   FEA
00492:  MOVLW  5F
00494:  MOVWF  FE9
00496:  BRA    066A
00498:  BCF    66.4
0049A:  BTFSC  65.7
0049C:  BRA    04B2
0049E:  BTFSS  64.0
004A0:  BRA    04C8
004A2:  RRCF   6A,F
004A4:  RRCF   69,F
004A6:  RRCF   68,F
004A8:  RRCF   67,F
004AA:  INCF   00,F
004AC:  BTFSC  FD8.2
004AE:  BRA    063A
004B0:  BRA    04C8
004B2:  BTFSC  6A.7
004B4:  BRA    04CE
004B6:  BCF    FD8.0
004B8:  RLCF   67,F
004BA:  RLCF   68,F
004BC:  RLCF   69,F
004BE:  RLCF   6A,F
004C0:  DECF   00,F
004C2:  BTFSC  FD8.2
004C4:  BRA    063A
004C6:  BRA    04B2
004C8:  BSF    66.6
004CA:  BRA    05A2
004CC:  BCF    66.6
004CE:  MOVFF  5D,65
004D2:  BTFSS  5D.7
004D4:  BRA    04DA
004D6:  BSF    6A.7
004D8:  BRA    062C
004DA:  BCF    6A.7
004DC:  BRA    062C
004DE:  MOVFF  60,64
004E2:  MOVFF  60,00
004E6:  MOVF   5C,W
004E8:  SUBWF  64,F
004EA:  MOVFF  5D,6A
004EE:  BSF    6A.7
004F0:  MOVFF  5E,69
004F4:  MOVFF  5F,68
004F8:  CLRF   67
004FA:  BCF    FD8.0
004FC:  RRCF   6A,F
004FE:  RRCF   69,F
00500:  RRCF   68,F
00502:  RRCF   67,F
00504:  DECFSZ 64,F
00506:  BRA    04F8
00508:  BTFSS  65.7
0050A:  BRA    0512
0050C:  BSF    66.1
0050E:  BRA    0644
00510:  BCF    66.1
00512:  BCF    64.0
00514:  BSF    66.5
00516:  CLRF   FEA
00518:  MOVLW  63
0051A:  MOVWF  FE9
0051C:  BRA    066A
0051E:  BCF    66.5
00520:  BTFSC  65.7
00522:  BRA    0538
00524:  BTFSS  64.0
00526:  BRA    054E
00528:  RRCF   6A,F
0052A:  RRCF   69,F
0052C:  RRCF   68,F
0052E:  RRCF   67,F
00530:  INCF   00,F
00532:  BTFSC  FD8.2
00534:  BRA    063A
00536:  BRA    054E
00538:  BTFSC  6A.7
0053A:  BRA    0554
0053C:  BCF    FD8.0
0053E:  RLCF   67,F
00540:  RLCF   68,F
00542:  RLCF   69,F
00544:  RLCF   6A,F
00546:  DECF   00,F
00548:  BTFSC  FD8.2
0054A:  BRA    063A
0054C:  BRA    0538
0054E:  BSF    66.7
00550:  BRA    05A2
00552:  BCF    66.7
00554:  MOVFF  61,65
00558:  BTFSS  61.7
0055A:  BRA    0560
0055C:  BSF    6A.7
0055E:  BRA    062C
00560:  BCF    6A.7
00562:  BRA    062C
00564:  MOVFF  61,6A
00568:  BSF    6A.7
0056A:  MOVFF  62,69
0056E:  MOVFF  63,68
00572:  BTFSS  65.7
00574:  BRA    057E
00576:  BCF    6A.7
00578:  BSF    66.2
0057A:  BRA    0644
0057C:  BCF    66.2
0057E:  CLRF   67
00580:  BCF    64.0
00582:  CLRF   FEA
00584:  MOVLW  5F
00586:  MOVWF  FE9
00588:  BRA    066A
0058A:  BTFSC  65.7
0058C:  BRA    05C6
0058E:  MOVFF  5D,65
00592:  BTFSS  64.0
00594:  BRA    05A2
00596:  RRCF   6A,F
00598:  RRCF   69,F
0059A:  RRCF   68,F
0059C:  RRCF   67,F
0059E:  INCF   00,F
005A0:  BZ    063A
005A2:  BTFSS  67.7
005A4:  BRA    05BC
005A6:  INCF   68,F
005A8:  BNZ   05BC
005AA:  INCF   69,F
005AC:  BNZ   05BC
005AE:  INCF   6A,F
005B0:  BNZ   05BC
005B2:  RRCF   6A,F
005B4:  RRCF   69,F
005B6:  RRCF   68,F
005B8:  INCF   00,F
005BA:  BZ    063A
005BC:  BTFSC  66.6
005BE:  BRA    04CC
005C0:  BTFSC  66.7
005C2:  BRA    0552
005C4:  BRA    05FE
005C6:  MOVLW  80
005C8:  XORWF  6A,F
005CA:  BTFSS  6A.7
005CC:  BRA    05D6
005CE:  BRA    0644
005D0:  MOVFF  61,65
005D4:  BRA    05EA
005D6:  MOVFF  5D,65
005DA:  MOVF   6A,F
005DC:  BNZ   05EA
005DE:  MOVF   69,F
005E0:  BNZ   05EA
005E2:  MOVF   68,F
005E4:  BNZ   05EA
005E6:  CLRF   00
005E8:  BRA    062C
005EA:  BTFSC  6A.7
005EC:  BRA    05FE
005EE:  BCF    FD8.0
005F0:  RLCF   67,F
005F2:  RLCF   68,F
005F4:  RLCF   69,F
005F6:  RLCF   6A,F
005F8:  DECFSZ 00,F
005FA:  BRA    05EA
005FC:  BRA    063A
005FE:  BTFSS  65.7
00600:  BRA    0606
00602:  BSF    6A.7
00604:  BRA    062C
00606:  BCF    6A.7
00608:  BRA    062C
0060A:  MOVFF  60,00
0060E:  MOVFF  61,6A
00612:  MOVFF  62,69
00616:  MOVFF  63,68
0061A:  BRA    062C
0061C:  MOVFF  5C,00
00620:  MOVFF  5D,6A
00624:  MOVFF  5E,69
00628:  MOVFF  5F,68
0062C:  MOVFF  6A,01
00630:  MOVFF  69,02
00634:  MOVFF  68,03
00638:  BRA    06A2
0063A:  CLRF   00
0063C:  CLRF   01
0063E:  CLRF   02
00640:  CLRF   03
00642:  BRA    06A2
00644:  CLRF   67
00646:  COMF   68,F
00648:  COMF   69,F
0064A:  COMF   6A,F
0064C:  COMF   67,F
0064E:  INCF   67,F
00650:  BNZ   065C
00652:  INCF   68,F
00654:  BNZ   065C
00656:  INCF   69,F
00658:  BNZ   065C
0065A:  INCF   6A,F
0065C:  BTFSC  66.0
0065E:  BRA    048A
00660:  BTFSC  66.1
00662:  BRA    0510
00664:  BTFSC  66.2
00666:  BRA    057C
00668:  BRA    05D0
0066A:  MOVF   FEF,W
0066C:  ADDWF  68,F
0066E:  BNC   067A
00670:  INCF   69,F
00672:  BNZ   067A
00674:  INCF   6A,F
00676:  BTFSC  FD8.2
00678:  BSF    64.0
0067A:  MOVF   FED,F
0067C:  MOVF   FEF,W
0067E:  ADDWF  69,F
00680:  BNC   0688
00682:  INCF   6A,F
00684:  BTFSC  FD8.2
00686:  BSF    64.0
00688:  MOVF   FED,F
0068A:  MOVF   FEF,W
0068C:  BTFSC  FEF.7
0068E:  BRA    0692
00690:  XORLW  80
00692:  ADDWF  6A,F
00694:  BTFSC  FD8.0
00696:  BSF    64.0
00698:  BTFSC  66.4
0069A:  BRA    0498
0069C:  BTFSC  66.5
0069E:  BRA    051E
006A0:  BRA    058A
006A2:  RETURN 0
*
008D6:  MOVLW  8E
008D8:  MOVWF  00
008DA:  MOVF   49,W
008DC:  SUBWF  00,F
008DE:  MOVFF  4A,02
008E2:  MOVFF  4B,01
008E6:  BSF    02.7
008E8:  MOVF   00,F
008EA:  BZ    08FE
008EC:  BCF    FD8.0
008EE:  MOVF   02,F
008F0:  BNZ   08F6
008F2:  MOVF   01,F
008F4:  BZ    08FE
008F6:  RRCF   02,F
008F8:  RRCF   01,F
008FA:  DECFSZ 00,F
008FC:  BRA    08EC
008FE:  BTFSS  4A.7
00900:  BRA    090C
00902:  COMF   01,F
00904:  COMF   02,F
00906:  INCF   01,F
00908:  BTFSC  FD8.2
0090A:  INCF   02,F
0090C:  RETURN 0
....................  
.................... #list 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
006A4:  CLRF   50
006A6:  CLRF   4F
006A8:  CLRF   4E
006AA:  MOVLW  7F
006AC:  MOVWF  4D
006AE:  CLRF   54
006B0:  CLRF   53
006B2:  CLRF   52
006B4:  CLRF   51
006B6:  BSF    55.0
006B8:  BCF    55.1
006BA:  BCF    55.2
006BC:  CLRF   57
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
006BE:  MOVF   49,W
006C0:  IORWF  4A,W
006C2:  BNZ   06CE
....................       return 0; 
006C4:  CLRF   00
006C6:  CLRF   01
006C8:  CLRF   02
006CA:  CLRF   03
006CC:  BRA    08D4
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
006CE:  MOVF   57,W
006D0:  INCF   57,F
006D2:  CLRF   03
006D4:  ADDWF  49,W
006D6:  MOVWF  FE9
006D8:  MOVF   4A,W
006DA:  ADDWFC 03,W
006DC:  MOVWF  FEA
006DE:  MOVFF  FEF,56
006E2:  MOVF   56,F
006E4:  BTFSC  FD8.2
006E6:  BRA    085E
....................    { 
....................       if (skip && !isspace(c)) 
006E8:  BTFSS  55.0
006EA:  BRA    070A
006EC:  MOVF   56,W
006EE:  SUBLW  20
006F0:  BZ    070A
....................       { 
....................          skip = 0; 
006F2:  BCF    55.0
....................          if (c == '+') 
006F4:  MOVF   56,W
006F6:  SUBLW  2B
006F8:  BNZ   0700
....................          { 
....................             sign = 0; 
006FA:  BCF    55.1
....................             continue; 
006FC:  BRA    0848
....................          }             
006FE:  BRA    070A
....................          else if (c == '-') 
00700:  MOVF   56,W
00702:  SUBLW  2D
00704:  BNZ   070A
....................          { 
....................             sign = 1; 
00706:  BSF    55.1
....................             continue; 
00708:  BRA    0848
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0070A:  BTFSC  55.0
0070C:  BRA    071C
0070E:  MOVF   56,W
00710:  SUBLW  2E
00712:  BNZ   071C
00714:  BTFSC  55.2
00716:  BRA    071C
....................          point = 1; 
00718:  BSF    55.2
0071A:  BRA    0848
....................       else if (!skip && isdigit(c)) 
0071C:  BTFSC  55.0
0071E:  BRA    0842
00720:  MOVF   56,W
00722:  SUBLW  2F
00724:  BTFSC  FD8.0
00726:  BRA    0842
00728:  MOVF   56,W
0072A:  SUBLW  39
0072C:  BTFSS  FD8.0
0072E:  BRA    0842
....................       { 
....................          c -= '0'; 
00730:  MOVLW  30
00732:  SUBWF  56,F
....................          if (point) 
00734:  BTFSS  55.2
00736:  BRA    07D6
....................          { 
....................             pow10 = pow10 * 10.0; 
00738:  MOVFF  50,5B
0073C:  MOVFF  4F,5A
00740:  MOVFF  4E,59
00744:  MOVFF  4D,58
00748:  CLRF   5F
0074A:  CLRF   5E
0074C:  MOVLW  20
0074E:  MOVWF  5D
00750:  MOVLW  82
00752:  MOVWF  5C
00754:  RCALL  01B6
00756:  MOVFF  03,50
0075A:  MOVFF  02,4F
0075E:  MOVFF  01,4E
00762:  MOVFF  00,4D
....................             result += (float)c / pow10;    
00766:  CLRF   5D
00768:  MOVFF  56,5C
0076C:  RCALL  02A8
0076E:  MOVFF  03,5B
00772:  MOVFF  02,5A
00776:  MOVFF  01,59
0077A:  MOVFF  00,58
0077E:  MOVFF  03,5F
00782:  MOVFF  02,5E
00786:  MOVFF  01,5D
0078A:  MOVFF  00,5C
0078E:  MOVFF  50,63
00792:  MOVFF  4F,62
00796:  MOVFF  4E,61
0079A:  MOVFF  4D,60
0079E:  BRA    02DE
007A0:  BCF    FD8.1
007A2:  MOVFF  54,5F
007A6:  MOVFF  53,5E
007AA:  MOVFF  52,5D
007AE:  MOVFF  51,5C
007B2:  MOVFF  03,63
007B6:  MOVFF  02,62
007BA:  MOVFF  01,61
007BE:  MOVFF  00,60
007C2:  RCALL  043A
007C4:  MOVFF  03,54
007C8:  MOVFF  02,53
007CC:  MOVFF  01,52
007D0:  MOVFF  00,51
....................          } 
007D4:  BRA    0840
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
007D6:  CLRF   5B
007D8:  CLRF   5A
007DA:  MOVLW  20
007DC:  MOVWF  59
007DE:  MOVLW  82
007E0:  MOVWF  58
007E2:  MOVFF  54,5F
007E6:  MOVFF  53,5E
007EA:  MOVFF  52,5D
007EE:  MOVFF  51,5C
007F2:  RCALL  01B6
007F4:  MOVFF  03,5B
007F8:  MOVFF  02,5A
007FC:  MOVFF  01,59
00800:  MOVFF  00,58
00804:  CLRF   5D
00806:  MOVFF  56,5C
0080A:  RCALL  02A8
0080C:  BCF    FD8.1
0080E:  MOVFF  5B,5F
00812:  MOVFF  5A,5E
00816:  MOVFF  59,5D
0081A:  MOVFF  58,5C
0081E:  MOVFF  03,63
00822:  MOVFF  02,62
00826:  MOVFF  01,61
0082A:  MOVFF  00,60
0082E:  RCALL  043A
00830:  MOVFF  03,54
00834:  MOVFF  02,53
00838:  MOVFF  01,52
0083C:  MOVFF  00,51
....................          } 
....................       } 
00840:  BRA    0848
....................       else if (!skip) 
00842:  BTFSC  55.0
00844:  BRA    0848
....................          break; 
00846:  BRA    085E
00848:  MOVF   57,W
0084A:  INCF   57,F
0084C:  CLRF   03
0084E:  ADDWF  49,W
00850:  MOVWF  FE9
00852:  MOVF   4A,W
00854:  ADDWFC 03,W
00856:  MOVWF  FEA
00858:  MOVFF  FEF,56
0085C:  BRA    06E2
....................    } 
....................  
....................    if (sign) 
0085E:  BTFSS  55.1
00860:  BRA    0890
....................       result = -1*result; 
00862:  CLRF   5B
00864:  CLRF   5A
00866:  MOVLW  80
00868:  MOVWF  59
0086A:  MOVLW  7F
0086C:  MOVWF  58
0086E:  MOVFF  54,5F
00872:  MOVFF  53,5E
00876:  MOVFF  52,5D
0087A:  MOVFF  51,5C
0087E:  RCALL  01B6
00880:  MOVFF  03,54
00884:  MOVFF  02,53
00888:  MOVFF  01,52
0088C:  MOVFF  00,51
....................        
....................    if(endptr) 
00890:  MOVF   4B,W
00892:  IORWF  4C,W
00894:  BZ    08C4
....................    { 
....................       if (ptr) { 
00896:  MOVF   57,F
00898:  BZ    08B2
....................          ptr--; 
0089A:  DECF   57,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0089C:  MOVFF  4B,FE9
008A0:  MOVFF  4C,FEA
008A4:  MOVF   57,W
008A6:  ADDWF  49,W
008A8:  MOVWF  FEF
008AA:  MOVLW  00
008AC:  ADDWFC 4A,W
008AE:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
008B0:  BRA    08C4
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
008B2:  MOVFF  4B,FE9
008B6:  MOVFF  4C,FEA
008BA:  MOVFF  4A,FEC
008BE:  MOVF   FED,F
008C0:  MOVFF  49,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
008C4:  MOVFF  51,00
008C8:  MOVFF  52,01
008CC:  MOVFF  53,02
008D0:  MOVFF  54,03
008D4:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #fuses HS, NOFCMEN, NOIESO, PUT, NOBROWNOUT, NOWDT 
.................... #fuses NOPBADEN, NOMCLR, STVREN, NOLVP, NODEBUG, XT 
.................... #use delay(clock=16000000) 
....................  
.................... #use fast_io(a) 
.................... #use fast_io(b) 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
....................  
.................... #define debugSerial 
....................  
.................... #ifdef debugSerial 
....................    #define TX_232        PIN_C6 
....................    #define RX_232        PIN_C7 
....................    #use RS232(BAUD=9600, XMIT=TX_232, BITS=8,PARITY=N, STOP=1,UART1,RCV=RX_232) 
*
001AC:  BTFSS  F9E.4
001AE:  BRA    01AC
001B0:  MOVWF  FAD
001B2:  GOTO   09E2 (RETURN)
.................... #endif 
....................  
.................... #define posInicialOp1 2 
.................... #define posInicialOp2 6 
.................... #define posinicialOp3 10 
....................  
.................... #define posFinalOp1 4 
.................... #define posFinalOp2 8 
.................... #define posFinalOp3 12 
....................  
.................... #define posCaracter 14  
....................  
.................... char caracter; 
.................... char bandera; 
.................... char echo; 
.................... char enter; 
.................... char cadena; 
.................... char puntoComa; 
.................... char convierte; 
....................  
.................... char buffRx[15]={}; 
.................... char buffOp1[3]={}; 
.................... char buffOp2[3]={}; 
.................... char buffOp3[3]={}; 
....................  
.................... int indexBff=0; 
.................... int sumaOp1=0; 
.................... int sumaOp2=0; 
.................... int sumaOp3=0; 
....................  
.................... int1 banderaOp1=0; 
.................... int1 banderaOp2=0; 
.................... int1 banderaOp3=0; 
....................  
.................... int1 banderaPuertoA=0; 
.................... int1 banderaPuertoB=0; 
.................... int1 banderaPuertoD=0; 
....................  
.................... int contador=0; 
.................... int contadorPuntoComa=0; 
.................... int contadorLsb = 0; 
....................  
.................... int contadorA=1; 
.................... int contadorB=1; 
.................... int contadorD=1; 
....................  
.................... #bit banderaSerial = bandera.0 
.................... #bit banderaEcho = echo.0 
.................... #bit banderaEnter = enter.0 
.................... #bit banderaCadena = cadena.0  
.................... #bit banderaPuntoComa = puntoComa.0 
.................... #bit banderaConvierte = convierte.0 
....................  
.................... #INT_RDA 
.................... void itrRDA(void) 
.................... { 
....................    caracter = getc(); 
*
000A2:  BTFSS  F9E.5
000A4:  BRA    00A2
000A6:  MOVFF  FAE,1C
....................    BuffRx[indexBff]=caracter; 
000AA:  CLRF   03
000AC:  MOVF   3B,W
000AE:  ADDLW  23
000B0:  MOVWF  FE9
000B2:  MOVLW  00
000B4:  ADDWFC 03,W
000B6:  MOVWF  FEA
000B8:  MOVFF  1C,FEF
....................    indexBff++; 
000BC:  INCF   3B,F
....................    banderaEcho = 1; 
000BE:  BSF    1E.0
....................    banderaSerial = 1; 
000C0:  BSF    1D.0
....................     
....................    if(caracter==0x0D) 
000C2:  MOVF   1C,W
000C4:  SUBLW  0D
000C6:  BNZ   00CA
....................    { 
....................       banderaEnter=1; 
000C8:  BSF    1F.0
....................    } 
....................    if (indexBff == 15) 
000CA:  MOVF   3B,W
000CC:  SUBLW  0F
000CE:  BNZ   00D2
....................    { 
....................       indexBff = 0; 
000D0:  CLRF   3B
....................    } 
....................    if(buffRx[0] == 0x3E && buffRx[indexBff-2] == 0x3C) 
000D2:  MOVF   23,W
000D4:  SUBLW  3E
000D6:  BNZ   00F0
000D8:  MOVLW  02
000DA:  SUBWF  3B,W
000DC:  CLRF   03
000DE:  ADDLW  23
000E0:  MOVWF  FE9
000E2:  MOVLW  00
000E4:  ADDWFC 03,W
000E6:  MOVWF  FEA
000E8:  MOVF   FEF,W
000EA:  SUBLW  3C
000EC:  BNZ   00F0
....................    { 
....................       banderaCadena = 1; 
000EE:  BSF    20.0
....................    } 
....................    if(buffRx[indexBff] == 0x3B) 
000F0:  CLRF   03
000F2:  MOVF   3B,W
000F4:  ADDLW  23
000F6:  MOVWF  FE9
000F8:  MOVLW  00
000FA:  ADDWFC 03,W
000FC:  MOVWF  FEA
000FE:  MOVF   FEF,W
00100:  SUBLW  3B
00102:  BNZ   0108
....................    { 
....................       banderaPuntoComa = 1; 
00104:  BSF    21.0
....................       contadorPuntoComa++; 
00106:  INCF   41,F
....................    } 
.................... } 
....................  
00108:  BCF    F9E.5
0010A:  GOTO   0060
.................... #int_timer0 
.................... void timer_0() 
.................... { 
....................    set_timer0(15536); 
0010E:  MOVLW  3C
00110:  MOVWF  FD7
00112:  MOVLW  B0
00114:  MOVWF  FD6
....................    contador++; 
00116:  INCF   40,F
00118:  BCF    FF2.2
0011A:  GOTO   0060
.................... } 
....................  
.................... void main(void) 
*
0090E:  CLRF   FF8
00910:  BCF    FD0.7
00912:  BSF    07.7
00914:  BSF    FB8.3
00916:  MOVLW  A0
00918:  MOVWF  FAF
0091A:  MOVLW  01
0091C:  MOVWF  FB0
0091E:  MOVLW  A6
00920:  MOVWF  FAC
00922:  MOVLW  90
00924:  MOVWF  FAB
00926:  CLRF   3B
00928:  CLRF   3C
0092A:  CLRF   3D
0092C:  CLRF   3E
0092E:  BCF    3F.0
00930:  BCF    3F.1
00932:  BCF    3F.2
00934:  BCF    3F.3
00936:  BCF    3F.4
00938:  BCF    3F.5
0093A:  CLRF   40
0093C:  CLRF   41
0093E:  CLRF   42
00940:  MOVLW  01
00942:  MOVWF  43
00944:  MOVWF  44
00946:  MOVWF  45
00948:  MOVF   FC1,W
0094A:  ANDLW  C0
0094C:  IORLW  0F
0094E:  MOVWF  FC1
00950:  MOVLW  07
00952:  MOVWF  FB4
00954:  BRA    0960
00956:  DATA 02,00
00958:  DATA 16,00
0095A:  DATA 00,18
0095C:  DATA 40,23
0095E:  DATA 00,00
00960:  MOVLW  00
00962:  MOVWF  FF8
00964:  MOVLW  09
00966:  MOVWF  FF7
00968:  MOVLW  56
0096A:  MOVWF  FF6
0096C:  TBLRD*+
0096E:  MOVF   FF5,W
00970:  MOVWF  00
00972:  XORLW  00
00974:  BZ    099C
00976:  TBLRD*+
00978:  MOVF   FF5,W
0097A:  MOVWF  01
0097C:  BTFSC  FE8.7
0097E:  BRA    098A
00980:  ANDLW  0F
00982:  MOVWF  FEA
00984:  TBLRD*+
00986:  MOVFF  FF5,FE9
0098A:  BTFSC  01.6
0098C:  TBLRD*+
0098E:  BTFSS  01.6
00990:  TBLRD*+
00992:  MOVFF  FF5,FEE
00996:  DCFSNZ 00,F
00998:  BRA    096C
0099A:  BRA    098E
0099C:  CLRF   FF8
.................... { 
....................    set_tris_a(0x00); 
0099E:  MOVLW  00
009A0:  MOVWF  F92
....................    set_tris_b(0x00); 
009A2:  MOVWF  F93
....................    set_tris_c(0x80); 
009A4:  MOVLW  80
009A6:  MOVWF  F94
....................    set_tris_d(0x00); 
009A8:  MOVLW  00
009AA:  MOVWF  F95
....................     
....................    setup_timer_0(rtcc_internal | rtcc_div_8); 
009AC:  MOVLW  82
009AE:  MOVWF  FD5
....................    set_timer0(15536); 
009B0:  MOVLW  3C
009B2:  MOVWF  FD7
009B4:  MOVLW  B0
009B6:  MOVWF  FD6
....................      
....................    enable_interrupts(int_timer0); 
009B8:  BSF    FF2.5
....................    enable_interrupts(global);    
009BA:  MOVLW  C0
009BC:  IORWF  FF2,F
....................    enable_interrupts(INT_RDA); 
009BE:  BSF    F9D.5
....................     
....................    printf("Ingresa los datos de la manera: >op1;op2;op3;caracter<"); 
009C0:  MOVLW  1E
009C2:  MOVWF  FF6
009C4:  MOVLW  01
009C6:  MOVWF  FF7
009C8:  CALL   018A
....................    printf("\n \r"); 
009CC:  MOVLW  56
009CE:  MOVWF  FF6
009D0:  MOVLW  01
009D2:  MOVWF  FF7
009D4:  CALL   018A
....................     
....................    while(TRUE) 
....................    { 
....................       if(banderaEcho) 
009D8:  BTFSS  1E.0
009DA:  BRA    09E4
....................       { 
....................          putc(caracter); 
009DC:  MOVF   1C,W
009DE:  GOTO   01AC
....................          banderaEcho = 0; 
009E2:  BCF    1E.0
....................       } 
....................        
....................       if(banderaPuntoComa) 
009E4:  BTFSS  21.0
009E6:  BRA    0AC0
....................       { 
....................          banderaPuntoComa=0; 
009E8:  BCF    21.0
....................          if(contadorPuntoComa==1) 
009EA:  DECFSZ 41,W
009EC:  BRA    0A30
....................          { 
....................             banderaOp1=1; 
009EE:  BSF    3F.0
....................             for(int index = posInicialOp1; index <= posFinalOp1; index++) 
009F0:  MOVLW  02
009F2:  MOVWF  46
009F4:  MOVF   46,W
009F6:  SUBLW  04
009F8:  BNC   0A2E
....................             { 
....................                buffOp1[index] = buffRx[index]; 
009FA:  CLRF   03
009FC:  MOVF   46,W
009FE:  ADDLW  32
00A00:  MOVWF  01
00A02:  MOVLW  00
00A04:  ADDWFC 03,F
00A06:  MOVFF  03,4A
00A0A:  CLRF   03
00A0C:  MOVF   46,W
00A0E:  ADDLW  23
00A10:  MOVWF  FE9
00A12:  MOVLW  00
00A14:  ADDWFC 03,W
00A16:  MOVWF  FEA
00A18:  MOVFF  FEF,4B
00A1C:  MOVFF  4A,FEA
00A20:  MOVFF  01,FE9
00A24:  MOVFF  4B,FEF
....................                banderaConvierte=1; 
00A28:  BSF    22.0
00A2A:  INCF   46,F
00A2C:  BRA    09F4
....................             } 
....................          } 
00A2E:  BRA    0AC0
....................          else if(contadorPuntoComa==2) 
00A30:  MOVF   41,W
00A32:  SUBLW  02
00A34:  BNZ   0A78
....................          { 
....................             banderaOp2=1; 
00A36:  BSF    3F.1
....................             for(int index = posInicialOp2; index <= posFinalOp2; index++) 
00A38:  MOVLW  06
00A3A:  MOVWF  47
00A3C:  MOVF   47,W
00A3E:  SUBLW  08
00A40:  BNC   0A76
....................             { 
....................                buffOp2[index] = buffRx[index]; 
00A42:  CLRF   03
00A44:  MOVF   47,W
00A46:  ADDLW  35
00A48:  MOVWF  01
00A4A:  MOVLW  00
00A4C:  ADDWFC 03,F
00A4E:  MOVFF  03,4A
00A52:  CLRF   03
00A54:  MOVF   47,W
00A56:  ADDLW  23
00A58:  MOVWF  FE9
00A5A:  MOVLW  00
00A5C:  ADDWFC 03,W
00A5E:  MOVWF  FEA
00A60:  MOVFF  FEF,4B
00A64:  MOVFF  4A,FEA
00A68:  MOVFF  01,FE9
00A6C:  MOVFF  4B,FEF
....................                banderaConvierte=1; 
00A70:  BSF    22.0
00A72:  INCF   47,F
00A74:  BRA    0A3C
....................             } 
....................          }          
00A76:  BRA    0AC0
....................          else if(contadorPuntoComa==3) 
00A78:  MOVF   41,W
00A7A:  SUBLW  03
00A7C:  BNZ   0AC0
....................          { 
....................             contadorPuntoComa=0; 
00A7E:  CLRF   41
....................             banderaOp3=1; 
00A80:  BSF    3F.2
....................             for(int index = posInicialOp3; index <= posFinalOp3; index++) 
00A82:  MOVLW  0A
00A84:  MOVWF  48
00A86:  MOVF   48,W
00A88:  SUBLW  0C
00A8A:  BNC   0AC0
....................             { 
....................                buffOp3[index] = buffRx[index]; 
00A8C:  CLRF   03
00A8E:  MOVF   48,W
00A90:  ADDLW  38
00A92:  MOVWF  01
00A94:  MOVLW  00
00A96:  ADDWFC 03,F
00A98:  MOVFF  03,4A
00A9C:  CLRF   03
00A9E:  MOVF   48,W
00AA0:  ADDLW  23
00AA2:  MOVWF  FE9
00AA4:  MOVLW  00
00AA6:  ADDWFC 03,W
00AA8:  MOVWF  FEA
00AAA:  MOVFF  FEF,4B
00AAE:  MOVFF  4A,FEA
00AB2:  MOVFF  01,FE9
00AB6:  MOVFF  4B,FEF
....................                banderaConvierte=1; 
00ABA:  BSF    22.0
00ABC:  INCF   48,F
00ABE:  BRA    0A86
....................             } 
....................          } 
....................       } 
....................        
....................       if(banderaConvierte) 
00AC0:  BTFSS  22.0
00AC2:  BRA    0B46
....................       { 
....................          if(banderaOp1) 
00AC4:  BTFSS  3F.0
00AC6:  BRA    0AF0
....................          { 
....................             banderaOp1=0; 
00AC8:  BCF    3F.0
....................             sumaOp1=0; 
00ACA:  CLRF   3C
....................             sumaOp1=atof(buffOp1); 
00ACC:  CLRF   4A
00ACE:  MOVLW  32
00AD0:  MOVWF  49
00AD2:  CLRF   4C
00AD4:  CLRF   4B
00AD6:  RCALL  06A4
00AD8:  MOVFF  03,4C
00ADC:  MOVFF  02,4B
00AE0:  MOVFF  01,4A
00AE4:  MOVFF  00,49
00AE8:  RCALL  08D6
00AEA:  MOVFF  01,3C
....................          } 
00AEE:  BRA    0B46
....................          else if(banderaOp2) 
00AF0:  BTFSS  3F.1
00AF2:  BRA    0B1C
....................          { 
....................             banderaOp2=0; 
00AF4:  BCF    3F.1
....................             sumaOp2=0; 
00AF6:  CLRF   3D
....................             sumaOp2=atof(buffOp2); 
00AF8:  CLRF   4A
00AFA:  MOVLW  35
00AFC:  MOVWF  49
00AFE:  CLRF   4C
00B00:  CLRF   4B
00B02:  RCALL  06A4
00B04:  MOVFF  03,4C
00B08:  MOVFF  02,4B
00B0C:  MOVFF  01,4A
00B10:  MOVFF  00,49
00B14:  RCALL  08D6
00B16:  MOVFF  01,3D
....................          } 
00B1A:  BRA    0B46
....................          else if(banderaOp3) 
00B1C:  BTFSS  3F.2
00B1E:  BRA    0B46
....................          { 
....................             banderaOp3=0; 
00B20:  BCF    3F.2
....................             sumaOp3=0; 
00B22:  CLRF   3E
....................             sumaOp3=atof(buffOp3); 
00B24:  CLRF   4A
00B26:  MOVLW  38
00B28:  MOVWF  49
00B2A:  CLRF   4C
00B2C:  CLRF   4B
00B2E:  RCALL  06A4
00B30:  MOVFF  03,4C
00B34:  MOVFF  02,4B
00B38:  MOVFF  01,4A
00B3C:  MOVFF  00,49
00B40:  RCALL  08D6
00B42:  MOVFF  01,3E
....................          } 
....................       } 
....................        
....................       if(banderaSerial) 
00B46:  BTFSS  1D.0
00B48:  BRA    0BC0
....................       { 
....................          banderaSerial=0; 
00B4A:  BCF    1D.0
....................          if(banderacadena) 
00B4C:  BTFSS  20.0
00B4E:  BRA    0B94
....................          { 
....................             banderaCadena=0; 
00B50:  BCF    20.0
....................             if(banderaEnter) 
00B52:  BTFSS  1F.0
00B54:  BRA    0B94
....................             { 
....................                banderaEnter=0; 
00B56:  BCF    1F.0
....................                if((sumaOp1&0x0C) > 0x00) 
00B58:  MOVF   3C,W
00B5A:  ANDLW  0C
00B5C:  BZ    0B62
....................                { 
....................                   banderaPuertoA=1; 
00B5E:  BSF    3F.3
....................                } 
00B60:  BRA    0B6C
....................                else if((sumaOp1&0x0C) != 0x0C) 
00B62:  MOVF   3C,W
00B64:  ANDLW  0C
00B66:  SUBLW  0C
00B68:  BZ    0B6C
....................                { 
....................                   banderaPuertoA=0; 
00B6A:  BCF    3F.3
....................                } 
....................                 
....................                if((sumaOp1&0x11) > 0x00) 
00B6C:  MOVF   3C,W
00B6E:  ANDLW  11
00B70:  BZ    0B76
....................                { 
....................                   banderaPuertoB=1; 
00B72:  BSF    3F.4
....................                } 
00B74:  BRA    0B80
....................                else if((sumaOp1&0x11) != 0x11) 
00B76:  MOVF   3C,W
00B78:  ANDLW  11
00B7A:  SUBLW  11
00B7C:  BZ    0B80
....................                { 
....................                   banderaPuertoB=0; 
00B7E:  BCF    3F.4
....................                } 
....................                 
....................                if((sumaOp1&0x42) > 0x00) 
00B80:  MOVF   3C,W
00B82:  ANDLW  42
00B84:  BZ    0B8A
....................                { 
....................                   banderaPuertoD=1; 
00B86:  BSF    3F.5
....................                } 
00B88:  BRA    0B94
....................                else if((sumaOp1&0x42) != 0x42) 
00B8A:  MOVF   3C,W
00B8C:  ANDLW  42
00B8E:  SUBLW  42
00B90:  BZ    0B94
....................                { 
....................                   banderaPuertoD=0; 
00B92:  BCF    3F.5
....................                } 
....................             } 
....................          } 
....................           
....................          if(banderaPuertoA) 
00B94:  BTFSS  3F.3
00B96:  BRA    0BA8
....................          { 
....................             contadorA = contadorA << 1; 
00B98:  BCF    FD8.0
00B9A:  RLCF   43,F
....................             if(contadorA == 128) 
00B9C:  MOVF   43,W
00B9E:  SUBLW  80
00BA0:  BNZ   0BA6
....................             { 
....................                contadorA = 1; 
00BA2:  MOVLW  01
00BA4:  MOVWF  43
....................             } 
....................          } 
00BA6:  BRA    0BC0
....................           
....................          else 
....................          { 
....................             printf("Error reingresa correctamente los datos..."); 
00BA8:  MOVLW  5A
00BAA:  MOVWF  FF6
00BAC:  MOVLW  01
00BAE:  MOVWF  FF7
00BB0:  CALL   018A
....................             printf("\n \r"); 
00BB4:  MOVLW  86
00BB6:  MOVWF  FF6
00BB8:  MOVLW  01
00BBA:  MOVWF  FF7
00BBC:  CALL   018A
....................          } 
....................       } 
00BC0:  BRA    09D8
....................    } 
.................... } 
00BC2:  SLEEP 

Configuration Fuses:
   Word  1: 0100   XT NOFCMEN NOIESO
   Word  2: 1E18   PUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 0500   CCP2C1 NOPBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
