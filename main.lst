CCS PCH C Compiler, Version 5.012, 41559               28-jun.-19 14:57

               Filename:   C:\Users\Usuario\Desktop\ordi\nombre\main.lst

               ROM used:   3094 bytes (5%)
                           Largest free fragment is 62438
               RAM used:   72 (2%) at main() level
                           109 (3%) worst case
               Stack used: 3 locations (2 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   08F6
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  FF2.5
0004A:  GOTO   0054
0004E:  BTFSC  FF2.2
00050:  GOTO   010E
00054:  BTFSS  F9D.5
00056:  GOTO   0060
0005A:  BTFSC  F9E.5
0005C:  GOTO   00A2
00060:  MOVFF  0E,00
00064:  MOVFF  0F,01
00068:  MOVFF  10,02
0006C:  MOVFF  11,03
00070:  MOVFF  0C,FE9
00074:  MOVFF  07,FEA
00078:  BSF    07.7
0007A:  MOVFF  08,FE1
0007E:  MOVFF  09,FE2
00082:  MOVFF  0A,FD9
00086:  MOVFF  0B,FDA
0008A:  MOVFF  12,FF3
0008E:  MOVFF  13,FF4
00092:  MOVFF  14,FFA
00096:  MOVF   04,W
00098:  MOVFF  06,FE0
0009C:  MOVFF  05,FD8
000A0:  RETFIE 0
.................... //Ordinario 4G// 
.................... #include <18f4620.h> 
.................... ///////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
*
0011C:  DATA 49,6E
0011E:  DATA 67,72
00120:  DATA 65,73
00122:  DATA 61,20
00124:  DATA 6C,6F
00126:  DATA 73,20
00128:  DATA 64,61
0012A:  DATA 74,6F
0012C:  DATA 73,20
0012E:  DATA 64,65
00130:  DATA 20,6C
00132:  DATA 61,20
00134:  DATA 6D,61
00136:  DATA 6E,65
00138:  DATA 72,61
0013A:  DATA 3A,20
0013C:  DATA 3E,6F
0013E:  DATA 70,31
00140:  DATA 3B,6F
00142:  DATA 70,32
00144:  DATA 3B,6F
00146:  DATA 70,33
00148:  DATA 3B,63
0014A:  DATA 61,72
0014C:  DATA 61,63
0014E:  DATA 74,65
00150:  DATA 72,3C
00152:  DATA 00,00
00154:  DATA 0A,20
00156:  DATA 0D,00
00158:  DATA 45,6C
0015A:  DATA 20,63
0015C:  DATA 61,72
0015E:  DATA 61,63
00160:  DATA 74,65
00162:  DATA 72,20
00164:  DATA 69,6E
00166:  DATA 67,72
00168:  DATA 65,73
0016A:  DATA 61,64
0016C:  DATA 6F,20
0016E:  DATA 65,73
00170:  DATA 3A,20
00172:  DATA 00,00
00174:  TBLRD*+
00176:  MOVF   FF5,F
00178:  BZ    0194
0017A:  MOVFF  FF6,48
0017E:  MOVFF  FF7,49
00182:  MOVF   FF5,W
00184:  BTFSS  F9E.4
00186:  BRA    0184
00188:  MOVWF  FAD
0018A:  MOVFF  48,FF6
0018E:  MOVFF  49,FF7
00192:  BRA    0174
00194:  RETURN 0
*
0019E:  MOVF   57,W
001A0:  BTFSC  FD8.2
001A2:  BRA    0286
001A4:  MOVWF  00
001A6:  MOVF   5B,W
001A8:  BTFSC  FD8.2
001AA:  BRA    0286
001AC:  ADDWF  00,F
001AE:  BNC   01B8
001B0:  MOVLW  81
001B2:  ADDWF  00,F
001B4:  BC    0286
001B6:  BRA    01C0
001B8:  MOVLW  7F
001BA:  SUBWF  00,F
001BC:  BNC   0286
001BE:  BZ    0286
001C0:  MOVFF  58,5F
001C4:  MOVF   5C,W
001C6:  XORWF  5F,F
001C8:  BSF    58.7
001CA:  BSF    5C.7
001CC:  MOVF   5A,W
001CE:  MULWF  5E
001D0:  MOVFF  FF4,61
001D4:  MOVF   59,W
001D6:  MULWF  5D
001D8:  MOVFF  FF4,03
001DC:  MOVFF  FF3,60
001E0:  MULWF  5E
001E2:  MOVF   FF3,W
001E4:  ADDWF  61,F
001E6:  MOVF   FF4,W
001E8:  ADDWFC 60,F
001EA:  MOVLW  00
001EC:  ADDWFC 03,F
001EE:  MOVF   5A,W
001F0:  MULWF  5D
001F2:  MOVF   FF3,W
001F4:  ADDWF  61,F
001F6:  MOVF   FF4,W
001F8:  ADDWFC 60,F
001FA:  MOVLW  00
001FC:  CLRF   02
001FE:  ADDWFC 03,F
00200:  ADDWFC 02,F
00202:  MOVF   58,W
00204:  MULWF  5E
00206:  MOVF   FF3,W
00208:  ADDWF  60,F
0020A:  MOVF   FF4,W
0020C:  ADDWFC 03,F
0020E:  MOVLW  00
00210:  ADDWFC 02,F
00212:  MOVF   58,W
00214:  MULWF  5D
00216:  MOVF   FF3,W
00218:  ADDWF  03,F
0021A:  MOVF   FF4,W
0021C:  ADDWFC 02,F
0021E:  MOVLW  00
00220:  CLRF   01
00222:  ADDWFC 01,F
00224:  MOVF   5A,W
00226:  MULWF  5C
00228:  MOVF   FF3,W
0022A:  ADDWF  60,F
0022C:  MOVF   FF4,W
0022E:  ADDWFC 03,F
00230:  MOVLW  00
00232:  ADDWFC 02,F
00234:  ADDWFC 01,F
00236:  MOVF   59,W
00238:  MULWF  5C
0023A:  MOVF   FF3,W
0023C:  ADDWF  03,F
0023E:  MOVF   FF4,W
00240:  ADDWFC 02,F
00242:  MOVLW  00
00244:  ADDWFC 01,F
00246:  MOVF   58,W
00248:  MULWF  5C
0024A:  MOVF   FF3,W
0024C:  ADDWF  02,F
0024E:  MOVF   FF4,W
00250:  ADDWFC 01,F
00252:  INCF   00,F
00254:  BTFSC  01.7
00256:  BRA    0262
00258:  RLCF   60,F
0025A:  RLCF   03,F
0025C:  RLCF   02,F
0025E:  RLCF   01,F
00260:  DECF   00,F
00262:  MOVLW  00
00264:  BTFSS  60.7
00266:  BRA    027C
00268:  INCF   03,F
0026A:  ADDWFC 02,F
0026C:  ADDWFC 01,F
0026E:  MOVF   01,W
00270:  BNZ   027C
00272:  MOVF   02,W
00274:  BNZ   027C
00276:  MOVF   03,W
00278:  BNZ   027C
0027A:  INCF   00,F
0027C:  BTFSC  5F.7
0027E:  BSF    01.7
00280:  BTFSS  5F.7
00282:  BCF    01.7
00284:  BRA    028E
00286:  CLRF   00
00288:  CLRF   01
0028A:  CLRF   02
0028C:  CLRF   03
0028E:  RETURN 0
00290:  MOVLW  8E
00292:  MOVWF  00
00294:  MOVFF  5C,01
00298:  MOVFF  5B,02
0029C:  CLRF   03
0029E:  MOVF   01,F
002A0:  BNZ   02B4
002A2:  MOVFF  02,01
002A6:  CLRF   02
002A8:  MOVLW  08
002AA:  SUBWF  00,F
002AC:  MOVF   01,F
002AE:  BNZ   02B4
002B0:  CLRF   00
002B2:  BRA    02C4
002B4:  BCF    FD8.0
002B6:  BTFSC  01.7
002B8:  BRA    02C2
002BA:  RLCF   02,F
002BC:  RLCF   01,F
002BE:  DECF   00,F
002C0:  BRA    02B4
002C2:  BCF    01.7
002C4:  RETURN 0
002C6:  MOVF   5B,W
002C8:  BTFSC  FD8.2
002CA:  BRA    0416
002CC:  MOVWF  67
002CE:  MOVF   5F,W
002D0:  BTFSC  FD8.2
002D2:  BRA    0416
002D4:  SUBWF  67,F
002D6:  BNC   02E2
002D8:  MOVLW  7F
002DA:  ADDWF  67,F
002DC:  BTFSC  FD8.0
002DE:  BRA    0416
002E0:  BRA    02EE
002E2:  MOVLW  81
002E4:  SUBWF  67,F
002E6:  BTFSS  FD8.0
002E8:  BRA    0416
002EA:  BTFSC  FD8.2
002EC:  BRA    0416
002EE:  MOVFF  67,00
002F2:  CLRF   01
002F4:  CLRF   02
002F6:  CLRF   03
002F8:  CLRF   66
002FA:  MOVFF  5C,65
002FE:  BSF    65.7
00300:  MOVFF  5D,64
00304:  MOVFF  5E,63
00308:  MOVLW  19
0030A:  MOVWF  67
0030C:  MOVF   62,W
0030E:  SUBWF  63,F
00310:  BC    032C
00312:  MOVLW  01
00314:  SUBWF  64,F
00316:  BC    032C
00318:  SUBWF  65,F
0031A:  BC    032C
0031C:  SUBWF  66,F
0031E:  BC    032C
00320:  INCF   66,F
00322:  INCF   65,F
00324:  INCF   64,F
00326:  MOVF   62,W
00328:  ADDWF  63,F
0032A:  BRA    037C
0032C:  MOVF   61,W
0032E:  SUBWF  64,F
00330:  BC    0356
00332:  MOVLW  01
00334:  SUBWF  65,F
00336:  BC    0356
00338:  SUBWF  66,F
0033A:  BC    0356
0033C:  INCF   66,F
0033E:  INCF   65,F
00340:  MOVF   61,W
00342:  ADDWF  64,F
00344:  MOVF   62,W
00346:  ADDWF  63,F
00348:  BNC   037C
0034A:  INCF   64,F
0034C:  BNZ   037C
0034E:  INCF   65,F
00350:  BNZ   037C
00352:  INCF   66,F
00354:  BRA    037C
00356:  MOVF   60,W
00358:  IORLW  80
0035A:  SUBWF  65,F
0035C:  BC    037A
0035E:  MOVLW  01
00360:  SUBWF  66,F
00362:  BC    037A
00364:  INCF   66,F
00366:  MOVF   60,W
00368:  IORLW  80
0036A:  ADDWF  65,F
0036C:  MOVF   61,W
0036E:  ADDWF  64,F
00370:  BNC   0344
00372:  INCF   65,F
00374:  BNZ   0344
00376:  INCF   66,F
00378:  BRA    0344
0037A:  BSF    03.0
0037C:  DECFSZ 67,F
0037E:  BRA    0382
00380:  BRA    0398
00382:  BCF    FD8.0
00384:  RLCF   63,F
00386:  RLCF   64,F
00388:  RLCF   65,F
0038A:  RLCF   66,F
0038C:  BCF    FD8.0
0038E:  RLCF   03,F
00390:  RLCF   02,F
00392:  RLCF   01,F
00394:  RLCF   68,F
00396:  BRA    030C
00398:  BTFSS  68.0
0039A:  BRA    03A8
0039C:  BCF    FD8.0
0039E:  RRCF   01,F
003A0:  RRCF   02,F
003A2:  RRCF   03,F
003A4:  RRCF   68,F
003A6:  BRA    03AC
003A8:  DECF   00,F
003AA:  BZ    0416
003AC:  BTFSC  68.7
003AE:  BRA    03EC
003B0:  BCF    FD8.0
003B2:  RLCF   63,F
003B4:  RLCF   64,F
003B6:  RLCF   65,F
003B8:  RLCF   66,F
003BA:  MOVF   62,W
003BC:  SUBWF  63,F
003BE:  BC    03CE
003C0:  MOVLW  01
003C2:  SUBWF  64,F
003C4:  BC    03CE
003C6:  SUBWF  65,F
003C8:  BC    03CE
003CA:  SUBWF  66,F
003CC:  BNC   0402
003CE:  MOVF   61,W
003D0:  SUBWF  64,F
003D2:  BC    03DE
003D4:  MOVLW  01
003D6:  SUBWF  65,F
003D8:  BC    03DE
003DA:  SUBWF  66,F
003DC:  BNC   0402
003DE:  MOVF   60,W
003E0:  IORLW  80
003E2:  SUBWF  65,F
003E4:  BC    03EC
003E6:  MOVLW  01
003E8:  SUBWF  66,F
003EA:  BNC   0402
003EC:  INCF   03,F
003EE:  BNZ   0402
003F0:  INCF   02,F
003F2:  BNZ   0402
003F4:  INCF   01,F
003F6:  BNZ   0402
003F8:  INCF   00,F
003FA:  BZ    0416
003FC:  RRCF   01,F
003FE:  RRCF   02,F
00400:  RRCF   03,F
00402:  MOVFF  5C,67
00406:  MOVF   60,W
00408:  XORWF  67,F
0040A:  BTFSS  67.7
0040C:  BRA    0412
0040E:  BSF    01.7
00410:  BRA    041E
00412:  BCF    01.7
00414:  BRA    041E
00416:  CLRF   00
00418:  CLRF   01
0041A:  CLRF   02
0041C:  CLRF   03
0041E:  GOTO   0788 (RETURN)
00422:  MOVLW  80
00424:  BTFSC  FD8.1
00426:  XORWF  60,F
00428:  CLRF   65
0042A:  CLRF   66
0042C:  MOVFF  5C,64
00430:  MOVF   60,W
00432:  XORWF  64,F
00434:  MOVF   5B,W
00436:  BTFSC  FD8.2
00438:  BRA    05F2
0043A:  MOVWF  63
0043C:  MOVWF  00
0043E:  MOVF   5F,W
00440:  BTFSC  FD8.2
00442:  BRA    0604
00444:  SUBWF  63,F
00446:  BTFSC  FD8.2
00448:  BRA    054C
0044A:  BNC   04C6
0044C:  MOVFF  60,69
00450:  BSF    69.7
00452:  MOVFF  61,68
00456:  MOVFF  62,67
0045A:  CLRF   66
0045C:  BCF    FD8.0
0045E:  RRCF   69,F
00460:  RRCF   68,F
00462:  RRCF   67,F
00464:  RRCF   66,F
00466:  DECFSZ 63,F
00468:  BRA    045A
0046A:  BTFSS  64.7
0046C:  BRA    0474
0046E:  BSF    65.0
00470:  BRA    062C
00472:  BCF    65.0
00474:  BCF    63.0
00476:  BSF    65.4
00478:  CLRF   FEA
0047A:  MOVLW  5E
0047C:  MOVWF  FE9
0047E:  BRA    0652
00480:  BCF    65.4
00482:  BTFSC  64.7
00484:  BRA    049A
00486:  BTFSS  63.0
00488:  BRA    04B0
0048A:  RRCF   69,F
0048C:  RRCF   68,F
0048E:  RRCF   67,F
00490:  RRCF   66,F
00492:  INCF   00,F
00494:  BTFSC  FD8.2
00496:  BRA    0622
00498:  BRA    04B0
0049A:  BTFSC  69.7
0049C:  BRA    04B6
0049E:  BCF    FD8.0
004A0:  RLCF   66,F
004A2:  RLCF   67,F
004A4:  RLCF   68,F
004A6:  RLCF   69,F
004A8:  DECF   00,F
004AA:  BTFSC  FD8.2
004AC:  BRA    0622
004AE:  BRA    049A
004B0:  BSF    65.6
004B2:  BRA    058A
004B4:  BCF    65.6
004B6:  MOVFF  5C,64
004BA:  BTFSS  5C.7
004BC:  BRA    04C2
004BE:  BSF    69.7
004C0:  BRA    0614
004C2:  BCF    69.7
004C4:  BRA    0614
004C6:  MOVFF  5F,63
004CA:  MOVFF  5F,00
004CE:  MOVF   5B,W
004D0:  SUBWF  63,F
004D2:  MOVFF  5C,69
004D6:  BSF    69.7
004D8:  MOVFF  5D,68
004DC:  MOVFF  5E,67
004E0:  CLRF   66
004E2:  BCF    FD8.0
004E4:  RRCF   69,F
004E6:  RRCF   68,F
004E8:  RRCF   67,F
004EA:  RRCF   66,F
004EC:  DECFSZ 63,F
004EE:  BRA    04E0
004F0:  BTFSS  64.7
004F2:  BRA    04FA
004F4:  BSF    65.1
004F6:  BRA    062C
004F8:  BCF    65.1
004FA:  BCF    63.0
004FC:  BSF    65.5
004FE:  CLRF   FEA
00500:  MOVLW  62
00502:  MOVWF  FE9
00504:  BRA    0652
00506:  BCF    65.5
00508:  BTFSC  64.7
0050A:  BRA    0520
0050C:  BTFSS  63.0
0050E:  BRA    0536
00510:  RRCF   69,F
00512:  RRCF   68,F
00514:  RRCF   67,F
00516:  RRCF   66,F
00518:  INCF   00,F
0051A:  BTFSC  FD8.2
0051C:  BRA    0622
0051E:  BRA    0536
00520:  BTFSC  69.7
00522:  BRA    053C
00524:  BCF    FD8.0
00526:  RLCF   66,F
00528:  RLCF   67,F
0052A:  RLCF   68,F
0052C:  RLCF   69,F
0052E:  DECF   00,F
00530:  BTFSC  FD8.2
00532:  BRA    0622
00534:  BRA    0520
00536:  BSF    65.7
00538:  BRA    058A
0053A:  BCF    65.7
0053C:  MOVFF  60,64
00540:  BTFSS  60.7
00542:  BRA    0548
00544:  BSF    69.7
00546:  BRA    0614
00548:  BCF    69.7
0054A:  BRA    0614
0054C:  MOVFF  60,69
00550:  BSF    69.7
00552:  MOVFF  61,68
00556:  MOVFF  62,67
0055A:  BTFSS  64.7
0055C:  BRA    0566
0055E:  BCF    69.7
00560:  BSF    65.2
00562:  BRA    062C
00564:  BCF    65.2
00566:  CLRF   66
00568:  BCF    63.0
0056A:  CLRF   FEA
0056C:  MOVLW  5E
0056E:  MOVWF  FE9
00570:  BRA    0652
00572:  BTFSC  64.7
00574:  BRA    05AE
00576:  MOVFF  5C,64
0057A:  BTFSS  63.0
0057C:  BRA    058A
0057E:  RRCF   69,F
00580:  RRCF   68,F
00582:  RRCF   67,F
00584:  RRCF   66,F
00586:  INCF   00,F
00588:  BZ    0622
0058A:  BTFSS  66.7
0058C:  BRA    05A4
0058E:  INCF   67,F
00590:  BNZ   05A4
00592:  INCF   68,F
00594:  BNZ   05A4
00596:  INCF   69,F
00598:  BNZ   05A4
0059A:  RRCF   69,F
0059C:  RRCF   68,F
0059E:  RRCF   67,F
005A0:  INCF   00,F
005A2:  BZ    0622
005A4:  BTFSC  65.6
005A6:  BRA    04B4
005A8:  BTFSC  65.7
005AA:  BRA    053A
005AC:  BRA    05E6
005AE:  MOVLW  80
005B0:  XORWF  69,F
005B2:  BTFSS  69.7
005B4:  BRA    05BE
005B6:  BRA    062C
005B8:  MOVFF  60,64
005BC:  BRA    05D2
005BE:  MOVFF  5C,64
005C2:  MOVF   69,F
005C4:  BNZ   05D2
005C6:  MOVF   68,F
005C8:  BNZ   05D2
005CA:  MOVF   67,F
005CC:  BNZ   05D2
005CE:  CLRF   00
005D0:  BRA    0614
005D2:  BTFSC  69.7
005D4:  BRA    05E6
005D6:  BCF    FD8.0
005D8:  RLCF   66,F
005DA:  RLCF   67,F
005DC:  RLCF   68,F
005DE:  RLCF   69,F
005E0:  DECFSZ 00,F
005E2:  BRA    05D2
005E4:  BRA    0622
005E6:  BTFSS  64.7
005E8:  BRA    05EE
005EA:  BSF    69.7
005EC:  BRA    0614
005EE:  BCF    69.7
005F0:  BRA    0614
005F2:  MOVFF  5F,00
005F6:  MOVFF  60,69
005FA:  MOVFF  61,68
005FE:  MOVFF  62,67
00602:  BRA    0614
00604:  MOVFF  5B,00
00608:  MOVFF  5C,69
0060C:  MOVFF  5D,68
00610:  MOVFF  5E,67
00614:  MOVFF  69,01
00618:  MOVFF  68,02
0061C:  MOVFF  67,03
00620:  BRA    068A
00622:  CLRF   00
00624:  CLRF   01
00626:  CLRF   02
00628:  CLRF   03
0062A:  BRA    068A
0062C:  CLRF   66
0062E:  COMF   67,F
00630:  COMF   68,F
00632:  COMF   69,F
00634:  COMF   66,F
00636:  INCF   66,F
00638:  BNZ   0644
0063A:  INCF   67,F
0063C:  BNZ   0644
0063E:  INCF   68,F
00640:  BNZ   0644
00642:  INCF   69,F
00644:  BTFSC  65.0
00646:  BRA    0472
00648:  BTFSC  65.1
0064A:  BRA    04F8
0064C:  BTFSC  65.2
0064E:  BRA    0564
00650:  BRA    05B8
00652:  MOVF   FEF,W
00654:  ADDWF  67,F
00656:  BNC   0662
00658:  INCF   68,F
0065A:  BNZ   0662
0065C:  INCF   69,F
0065E:  BTFSC  FD8.2
00660:  BSF    63.0
00662:  MOVF   FED,F
00664:  MOVF   FEF,W
00666:  ADDWF  68,F
00668:  BNC   0670
0066A:  INCF   69,F
0066C:  BTFSC  FD8.2
0066E:  BSF    63.0
00670:  MOVF   FED,F
00672:  MOVF   FEF,W
00674:  BTFSC  FEF.7
00676:  BRA    067A
00678:  XORLW  80
0067A:  ADDWF  69,F
0067C:  BTFSC  FD8.0
0067E:  BSF    63.0
00680:  BTFSC  65.4
00682:  BRA    0480
00684:  BTFSC  65.5
00686:  BRA    0506
00688:  BRA    0572
0068A:  RETURN 0
*
008BE:  MOVLW  8E
008C0:  MOVWF  00
008C2:  MOVF   48,W
008C4:  SUBWF  00,F
008C6:  MOVFF  49,02
008CA:  MOVFF  4A,01
008CE:  BSF    02.7
008D0:  MOVF   00,F
008D2:  BZ    08E6
008D4:  BCF    FD8.0
008D6:  MOVF   02,F
008D8:  BNZ   08DE
008DA:  MOVF   01,F
008DC:  BZ    08E6
008DE:  RRCF   02,F
008E0:  RRCF   01,F
008E2:  DECFSZ 00,F
008E4:  BRA    08D4
008E6:  BTFSS  49.7
008E8:  BRA    08F4
008EA:  COMF   01,F
008EC:  COMF   02,F
008EE:  INCF   01,F
008F0:  BTFSC  FD8.2
008F2:  INCF   02,F
008F4:  RETURN 0
....................  
.................... #list 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
0068C:  CLRF   4F
0068E:  CLRF   4E
00690:  CLRF   4D
00692:  MOVLW  7F
00694:  MOVWF  4C
00696:  CLRF   53
00698:  CLRF   52
0069A:  CLRF   51
0069C:  CLRF   50
0069E:  BSF    54.0
006A0:  BCF    54.1
006A2:  BCF    54.2
006A4:  CLRF   56
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
006A6:  MOVF   48,W
006A8:  IORWF  49,W
006AA:  BNZ   06B6
....................       return 0; 
006AC:  CLRF   00
006AE:  CLRF   01
006B0:  CLRF   02
006B2:  CLRF   03
006B4:  BRA    08BC
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
006B6:  MOVF   56,W
006B8:  INCF   56,F
006BA:  CLRF   03
006BC:  ADDWF  48,W
006BE:  MOVWF  FE9
006C0:  MOVF   49,W
006C2:  ADDWFC 03,W
006C4:  MOVWF  FEA
006C6:  MOVFF  FEF,55
006CA:  MOVF   55,F
006CC:  BTFSC  FD8.2
006CE:  BRA    0846
....................    { 
....................       if (skip && !isspace(c)) 
006D0:  BTFSS  54.0
006D2:  BRA    06F2
006D4:  MOVF   55,W
006D6:  SUBLW  20
006D8:  BZ    06F2
....................       { 
....................          skip = 0; 
006DA:  BCF    54.0
....................          if (c == '+') 
006DC:  MOVF   55,W
006DE:  SUBLW  2B
006E0:  BNZ   06E8
....................          { 
....................             sign = 0; 
006E2:  BCF    54.1
....................             continue; 
006E4:  BRA    0830
....................          }             
006E6:  BRA    06F2
....................          else if (c == '-') 
006E8:  MOVF   55,W
006EA:  SUBLW  2D
006EC:  BNZ   06F2
....................          { 
....................             sign = 1; 
006EE:  BSF    54.1
....................             continue; 
006F0:  BRA    0830
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
006F2:  BTFSC  54.0
006F4:  BRA    0704
006F6:  MOVF   55,W
006F8:  SUBLW  2E
006FA:  BNZ   0704
006FC:  BTFSC  54.2
006FE:  BRA    0704
....................          point = 1; 
00700:  BSF    54.2
00702:  BRA    0830
....................       else if (!skip && isdigit(c)) 
00704:  BTFSC  54.0
00706:  BRA    082A
00708:  MOVF   55,W
0070A:  SUBLW  2F
0070C:  BTFSC  FD8.0
0070E:  BRA    082A
00710:  MOVF   55,W
00712:  SUBLW  39
00714:  BTFSS  FD8.0
00716:  BRA    082A
....................       { 
....................          c -= '0'; 
00718:  MOVLW  30
0071A:  SUBWF  55,F
....................          if (point) 
0071C:  BTFSS  54.2
0071E:  BRA    07BE
....................          { 
....................             pow10 = pow10 * 10.0; 
00720:  MOVFF  4F,5A
00724:  MOVFF  4E,59
00728:  MOVFF  4D,58
0072C:  MOVFF  4C,57
00730:  CLRF   5E
00732:  CLRF   5D
00734:  MOVLW  20
00736:  MOVWF  5C
00738:  MOVLW  82
0073A:  MOVWF  5B
0073C:  RCALL  019E
0073E:  MOVFF  03,4F
00742:  MOVFF  02,4E
00746:  MOVFF  01,4D
0074A:  MOVFF  00,4C
....................             result += (float)c / pow10;    
0074E:  CLRF   5C
00750:  MOVFF  55,5B
00754:  RCALL  0290
00756:  MOVFF  03,5A
0075A:  MOVFF  02,59
0075E:  MOVFF  01,58
00762:  MOVFF  00,57
00766:  MOVFF  03,5E
0076A:  MOVFF  02,5D
0076E:  MOVFF  01,5C
00772:  MOVFF  00,5B
00776:  MOVFF  4F,62
0077A:  MOVFF  4E,61
0077E:  MOVFF  4D,60
00782:  MOVFF  4C,5F
00786:  BRA    02C6
00788:  BCF    FD8.1
0078A:  MOVFF  53,5E
0078E:  MOVFF  52,5D
00792:  MOVFF  51,5C
00796:  MOVFF  50,5B
0079A:  MOVFF  03,62
0079E:  MOVFF  02,61
007A2:  MOVFF  01,60
007A6:  MOVFF  00,5F
007AA:  RCALL  0422
007AC:  MOVFF  03,53
007B0:  MOVFF  02,52
007B4:  MOVFF  01,51
007B8:  MOVFF  00,50
....................          } 
007BC:  BRA    0828
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
007BE:  CLRF   5A
007C0:  CLRF   59
007C2:  MOVLW  20
007C4:  MOVWF  58
007C6:  MOVLW  82
007C8:  MOVWF  57
007CA:  MOVFF  53,5E
007CE:  MOVFF  52,5D
007D2:  MOVFF  51,5C
007D6:  MOVFF  50,5B
007DA:  RCALL  019E
007DC:  MOVFF  03,5A
007E0:  MOVFF  02,59
007E4:  MOVFF  01,58
007E8:  MOVFF  00,57
007EC:  CLRF   5C
007EE:  MOVFF  55,5B
007F2:  RCALL  0290
007F4:  BCF    FD8.1
007F6:  MOVFF  5A,5E
007FA:  MOVFF  59,5D
007FE:  MOVFF  58,5C
00802:  MOVFF  57,5B
00806:  MOVFF  03,62
0080A:  MOVFF  02,61
0080E:  MOVFF  01,60
00812:  MOVFF  00,5F
00816:  RCALL  0422
00818:  MOVFF  03,53
0081C:  MOVFF  02,52
00820:  MOVFF  01,51
00824:  MOVFF  00,50
....................          } 
....................       } 
00828:  BRA    0830
....................       else if (!skip) 
0082A:  BTFSC  54.0
0082C:  BRA    0830
....................          break; 
0082E:  BRA    0846
00830:  MOVF   56,W
00832:  INCF   56,F
00834:  CLRF   03
00836:  ADDWF  48,W
00838:  MOVWF  FE9
0083A:  MOVF   49,W
0083C:  ADDWFC 03,W
0083E:  MOVWF  FEA
00840:  MOVFF  FEF,55
00844:  BRA    06CA
....................    } 
....................  
....................    if (sign) 
00846:  BTFSS  54.1
00848:  BRA    0878
....................       result = -1*result; 
0084A:  CLRF   5A
0084C:  CLRF   59
0084E:  MOVLW  80
00850:  MOVWF  58
00852:  MOVLW  7F
00854:  MOVWF  57
00856:  MOVFF  53,5E
0085A:  MOVFF  52,5D
0085E:  MOVFF  51,5C
00862:  MOVFF  50,5B
00866:  RCALL  019E
00868:  MOVFF  03,53
0086C:  MOVFF  02,52
00870:  MOVFF  01,51
00874:  MOVFF  00,50
....................        
....................    if(endptr) 
00878:  MOVF   4A,W
0087A:  IORWF  4B,W
0087C:  BZ    08AC
....................    { 
....................       if (ptr) { 
0087E:  MOVF   56,F
00880:  BZ    089A
....................          ptr--; 
00882:  DECF   56,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
00884:  MOVFF  4A,FE9
00888:  MOVFF  4B,FEA
0088C:  MOVF   56,W
0088E:  ADDWF  48,W
00890:  MOVWF  FEF
00892:  MOVLW  00
00894:  ADDWFC 49,W
00896:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
00898:  BRA    08AC
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0089A:  MOVFF  4A,FE9
0089E:  MOVFF  4B,FEA
008A2:  MOVFF  49,FEC
008A6:  MOVF   FED,F
008A8:  MOVFF  48,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
008AC:  MOVFF  50,00
008B0:  MOVFF  51,01
008B4:  MOVFF  52,02
008B8:  MOVFF  53,03
008BC:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #fuses HS, NOFCMEN, NOIESO, PUT, NOBROWNOUT, NOWDT 
.................... #fuses NOPBADEN, NOMCLR, STVREN, NOLVP, NODEBUG, XT 
.................... #use delay(clock=4000000) 
....................  
.................... #use fast_io(a) 
.................... #use fast_io(b) 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
....................  
.................... #define debugSerial 
....................  
.................... #ifdef debugSerial 
....................    #define TX_232        PIN_C6 
....................    #define RX_232        PIN_C7 
....................    #use RS232(BAUD=9600, XMIT=TX_232, BITS=8,PARITY=N, STOP=1,UART1,RCV=RX_232) 
*
00196:  BTFSS  F9E.4
00198:  BRA    0196
0019A:  MOVWF  FAD
0019C:  RETURN 0
.................... #endif 
....................  
.................... #define posInicialOp1 2 
.................... #define posInicialOp2 6 
.................... #define posinicialOp3 10 
....................  
.................... #define posFinalOp1 4 
.................... #define posFinalOp2 8 
.................... #define posFinalOp3 12 
....................  
.................... #define posCaracter 14  
....................  
.................... char caracter; 
.................... char bandera; 
.................... char echo; 
.................... char enter; 
.................... char cadena; 
.................... char puntoComa; 
.................... char convierte; 
....................  
.................... char buffRx[15]={}; 
.................... char buffOp1[3]={}; 
.................... char buffOp2[3]={}; 
.................... char buffOp3[3]={}; 
....................  
.................... int indexBff=0; 
.................... int sumaOp1=0; 
.................... int sumaOp2=0; 
.................... int sumaOp3=0; 
....................  
.................... int1 banderaOp1=0; 
.................... int1 banderaOp2=0; 
.................... int1 banderaOp3=0; 
....................  
.................... int1 banderaPuertoA=0; 
.................... int1 banderaPuertoB=0; 
.................... int1 banderaPuertoD=0; 
.................... int1 banderaImprime=0; 
....................  
.................... int contador=0; 
.................... int contadorPuntoComa=0; 
....................  
.................... int contadorA=1; 
.................... int contadorB=1; 
.................... int contadorD=1; 
....................  
.................... #bit banderaSerial = bandera.0 
.................... #bit banderaEcho = echo.0 
.................... #bit banderaEnter = enter.0 
.................... #bit banderaCadena = cadena.0  
.................... #bit banderaPuntoComa = puntoComa.0 
.................... #bit banderaConvierte = convierte.0 
....................  
.................... #INT_RDA 
.................... void itrRDA(void) 
.................... { 
....................    caracter = getc(); 
*
000A2:  BTFSS  F9E.5
000A4:  BRA    00A2
000A6:  MOVFF  FAE,1C
....................    BuffRx[indexBff]=caracter; 
000AA:  CLRF   03
000AC:  MOVF   3B,W
000AE:  ADDLW  23
000B0:  MOVWF  FE9
000B2:  MOVLW  00
000B4:  ADDWFC 03,W
000B6:  MOVWF  FEA
000B8:  MOVFF  1C,FEF
....................    indexBff++; 
000BC:  INCF   3B,F
....................    banderaEcho = 1; 
000BE:  BSF    1E.0
....................    banderaSerial = 1; 
000C0:  BSF    1D.0
....................     
....................    if(caracter==0x0D) 
000C2:  MOVF   1C,W
000C4:  SUBLW  0D
000C6:  BNZ   00CA
....................    { 
....................       banderaEnter=1; 
000C8:  BSF    1F.0
....................    } 
....................    if (indexBff > 15) 
000CA:  MOVF   3B,W
000CC:  SUBLW  0F
000CE:  BC    00D2
....................    { 
....................       indexBff = 0; 
000D0:  CLRF   3B
....................    } 
....................    if(buffRx[0] == 0x3E && buffRx[indexBff-2] == 0x3C) 
000D2:  MOVF   23,W
000D4:  SUBLW  3E
000D6:  BNZ   00F0
000D8:  MOVLW  02
000DA:  SUBWF  3B,W
000DC:  CLRF   03
000DE:  ADDLW  23
000E0:  MOVWF  FE9
000E2:  MOVLW  00
000E4:  ADDWFC 03,W
000E6:  MOVWF  FEA
000E8:  MOVF   FEF,W
000EA:  SUBLW  3C
000EC:  BNZ   00F0
....................    { 
....................       banderaCadena = 1; 
000EE:  BSF    20.0
....................    } 
....................    if(buffRx[indexBff] == 0x3B) 
000F0:  CLRF   03
000F2:  MOVF   3B,W
000F4:  ADDLW  23
000F6:  MOVWF  FE9
000F8:  MOVLW  00
000FA:  ADDWFC 03,W
000FC:  MOVWF  FEA
000FE:  MOVF   FEF,W
00100:  SUBLW  3B
00102:  BNZ   0108
....................    { 
....................       banderaPuntoComa = 1; 
00104:  BSF    21.0
....................       contadorPuntoComa++; 
00106:  INCF   41,F
....................    } 
.................... } 
....................  
00108:  BCF    F9E.5
0010A:  GOTO   0060
.................... #int_timer0 
.................... void timer_0() 
.................... { 
....................    set_timer0(56); 
0010E:  CLRF   FD7
00110:  MOVLW  38
00112:  MOVWF  FD6
....................    contador++; 
00114:  INCF   40,F
00116:  BCF    FF2.2
00118:  GOTO   0060
.................... } 
....................  
.................... void main(void) 
*
008F6:  CLRF   FF8
008F8:  BCF    FD0.7
008FA:  BSF    07.7
008FC:  BCF    FB8.3
008FE:  MOVLW  19
00900:  MOVWF  FAF
00902:  MOVLW  A6
00904:  MOVWF  FAC
00906:  MOVLW  90
00908:  MOVWF  FAB
0090A:  CLRF   3B
0090C:  CLRF   3C
0090E:  CLRF   3D
00910:  CLRF   3E
00912:  BCF    3F.0
00914:  BCF    3F.1
00916:  BCF    3F.2
00918:  BCF    3F.3
0091A:  BCF    3F.4
0091C:  BCF    3F.5
0091E:  BCF    3F.6
00920:  CLRF   40
00922:  CLRF   41
00924:  MOVLW  01
00926:  MOVWF  42
00928:  MOVWF  43
0092A:  MOVWF  44
0092C:  MOVF   FC1,W
0092E:  ANDLW  C0
00930:  IORLW  0F
00932:  MOVWF  FC1
00934:  MOVLW  07
00936:  MOVWF  FB4
00938:  BRA    0944
0093A:  DATA 02,00
0093C:  DATA 16,00
0093E:  DATA 00,18
00940:  DATA 40,23
00942:  DATA 00,00
00944:  MOVLW  00
00946:  MOVWF  FF8
00948:  MOVLW  09
0094A:  MOVWF  FF7
0094C:  MOVLW  3A
0094E:  MOVWF  FF6
00950:  TBLRD*+
00952:  MOVF   FF5,W
00954:  MOVWF  00
00956:  XORLW  00
00958:  BZ    0980
0095A:  TBLRD*+
0095C:  MOVF   FF5,W
0095E:  MOVWF  01
00960:  BTFSC  FE8.7
00962:  BRA    096E
00964:  ANDLW  0F
00966:  MOVWF  FEA
00968:  TBLRD*+
0096A:  MOVFF  FF5,FE9
0096E:  BTFSC  01.6
00970:  TBLRD*+
00972:  BTFSS  01.6
00974:  TBLRD*+
00976:  MOVFF  FF5,FEE
0097A:  DCFSNZ 00,F
0097C:  BRA    0950
0097E:  BRA    0972
00980:  CLRF   FF8
.................... { 
....................    set_tris_a(0x00); 
00982:  MOVLW  00
00984:  MOVWF  F92
....................    set_tris_b(0x00); 
00986:  MOVWF  F93
....................    set_tris_c(0x80); 
00988:  MOVLW  80
0098A:  MOVWF  F94
....................    set_tris_d(0x00); 
0098C:  MOVLW  00
0098E:  MOVWF  F95
....................     
....................    setup_timer_0(rtcc_internal | rtcc_div_32); 
00990:  MOVLW  84
00992:  MOVWF  FD5
....................    set_timer0(56); 
00994:  CLRF   FD7
00996:  MOVLW  38
00998:  MOVWF  FD6
....................      
....................    enable_interrupts(int_timer0); 
0099A:  BSF    FF2.5
....................    enable_interrupts(global);    
0099C:  MOVLW  C0
0099E:  IORWF  FF2,F
....................    enable_interrupts(INT_RDA); 
009A0:  BSF    F9D.5
....................     
....................    printf("Ingresa los datos de la manera: >op1;op2;op3;caracter<"); 
009A2:  MOVLW  1C
009A4:  MOVWF  FF6
009A6:  MOVLW  01
009A8:  MOVWF  FF7
009AA:  CALL   0174
....................    printf("\n \r"); 
009AE:  MOVLW  54
009B0:  MOVWF  FF6
009B2:  MOVLW  01
009B4:  MOVWF  FF7
009B6:  CALL   0174
....................     
....................    while(TRUE) 
....................    { 
....................       if(banderaEcho) 
009BA:  BTFSS  1E.0
009BC:  BRA    09C6
....................       { 
....................          putc(caracter); 
009BE:  MOVF   1C,W
009C0:  CALL   0196
....................          banderaEcho = 0; 
009C4:  BCF    1E.0
....................       } 
....................        
....................       if(banderaPuntoComa) 
009C6:  BTFSS  21.0
009C8:  BRA    0AA2
....................       { 
....................          banderaPuntoComa=0; 
009CA:  BCF    21.0
....................          if(contadorPuntoComa==1) 
009CC:  DECFSZ 41,W
009CE:  BRA    0A12
....................          { 
....................             banderaOp1=1; 
009D0:  BSF    3F.0
....................             for(int index = posInicialOp1; index <= posFinalOp1; index++) 
009D2:  MOVLW  02
009D4:  MOVWF  45
009D6:  MOVF   45,W
009D8:  SUBLW  04
009DA:  BNC   0A10
....................             { 
....................                buffOp1[index] = buffRx[index]; 
009DC:  CLRF   03
009DE:  MOVF   45,W
009E0:  ADDLW  32
009E2:  MOVWF  01
009E4:  MOVLW  00
009E6:  ADDWFC 03,F
009E8:  MOVFF  03,49
009EC:  CLRF   03
009EE:  MOVF   45,W
009F0:  ADDLW  23
009F2:  MOVWF  FE9
009F4:  MOVLW  00
009F6:  ADDWFC 03,W
009F8:  MOVWF  FEA
009FA:  MOVFF  FEF,4A
009FE:  MOVFF  49,FEA
00A02:  MOVFF  01,FE9
00A06:  MOVFF  4A,FEF
....................                banderaConvierte=1; 
00A0A:  BSF    22.0
00A0C:  INCF   45,F
00A0E:  BRA    09D6
....................             } 
....................          } 
00A10:  BRA    0AA2
....................          else if(contadorPuntoComa==2) 
00A12:  MOVF   41,W
00A14:  SUBLW  02
00A16:  BNZ   0A5A
....................          { 
....................             banderaOp2=1; 
00A18:  BSF    3F.1
....................             for(int index = posInicialOp2; index <= posFinalOp2; index++) 
00A1A:  MOVLW  06
00A1C:  MOVWF  46
00A1E:  MOVF   46,W
00A20:  SUBLW  08
00A22:  BNC   0A58
....................             { 
....................                buffOp2[index] = buffRx[index]; 
00A24:  CLRF   03
00A26:  MOVF   46,W
00A28:  ADDLW  35
00A2A:  MOVWF  01
00A2C:  MOVLW  00
00A2E:  ADDWFC 03,F
00A30:  MOVFF  03,49
00A34:  CLRF   03
00A36:  MOVF   46,W
00A38:  ADDLW  23
00A3A:  MOVWF  FE9
00A3C:  MOVLW  00
00A3E:  ADDWFC 03,W
00A40:  MOVWF  FEA
00A42:  MOVFF  FEF,4A
00A46:  MOVFF  49,FEA
00A4A:  MOVFF  01,FE9
00A4E:  MOVFF  4A,FEF
....................                banderaConvierte=1; 
00A52:  BSF    22.0
00A54:  INCF   46,F
00A56:  BRA    0A1E
....................             } 
....................          }          
00A58:  BRA    0AA2
....................          else if(contadorPuntoComa==3) 
00A5A:  MOVF   41,W
00A5C:  SUBLW  03
00A5E:  BNZ   0AA2
....................          { 
....................             contadorPuntoComa=0; 
00A60:  CLRF   41
....................             banderaOp3=1; 
00A62:  BSF    3F.2
....................             for(int index = posInicialOp3; index <= posFinalOp3; index++) 
00A64:  MOVLW  0A
00A66:  MOVWF  47
00A68:  MOVF   47,W
00A6A:  SUBLW  0C
00A6C:  BNC   0AA2
....................             { 
....................                buffOp3[index] = buffRx[index]; 
00A6E:  CLRF   03
00A70:  MOVF   47,W
00A72:  ADDLW  38
00A74:  MOVWF  01
00A76:  MOVLW  00
00A78:  ADDWFC 03,F
00A7A:  MOVFF  03,49
00A7E:  CLRF   03
00A80:  MOVF   47,W
00A82:  ADDLW  23
00A84:  MOVWF  FE9
00A86:  MOVLW  00
00A88:  ADDWFC 03,W
00A8A:  MOVWF  FEA
00A8C:  MOVFF  FEF,4A
00A90:  MOVFF  49,FEA
00A94:  MOVFF  01,FE9
00A98:  MOVFF  4A,FEF
....................                banderaConvierte=1; 
00A9C:  BSF    22.0
00A9E:  INCF   47,F
00AA0:  BRA    0A68
....................             } 
....................          } 
....................       } 
....................        
....................       if(banderaConvierte) 
00AA2:  BTFSS  22.0
00AA4:  BRA    0B28
....................       { 
....................          if(banderaOp1) 
00AA6:  BTFSS  3F.0
00AA8:  BRA    0AD2
....................          { 
....................             banderaOp1=0; 
00AAA:  BCF    3F.0
....................             sumaOp1=0; 
00AAC:  CLRF   3C
....................             sumaOp1=atof(buffOp1); 
00AAE:  CLRF   49
00AB0:  MOVLW  32
00AB2:  MOVWF  48
00AB4:  CLRF   4B
00AB6:  CLRF   4A
00AB8:  RCALL  068C
00ABA:  MOVFF  03,4B
00ABE:  MOVFF  02,4A
00AC2:  MOVFF  01,49
00AC6:  MOVFF  00,48
00ACA:  RCALL  08BE
00ACC:  MOVFF  01,3C
....................          } 
00AD0:  BRA    0B28
....................          else if(banderaOp2) 
00AD2:  BTFSS  3F.1
00AD4:  BRA    0AFE
....................          { 
....................             banderaOp2=0; 
00AD6:  BCF    3F.1
....................             sumaOp2=0; 
00AD8:  CLRF   3D
....................             sumaOp2=atof(buffOp2); 
00ADA:  CLRF   49
00ADC:  MOVLW  35
00ADE:  MOVWF  48
00AE0:  CLRF   4B
00AE2:  CLRF   4A
00AE4:  RCALL  068C
00AE6:  MOVFF  03,4B
00AEA:  MOVFF  02,4A
00AEE:  MOVFF  01,49
00AF2:  MOVFF  00,48
00AF6:  RCALL  08BE
00AF8:  MOVFF  01,3D
....................          } 
00AFC:  BRA    0B28
....................          else if(banderaOp3) 
00AFE:  BTFSS  3F.2
00B00:  BRA    0B28
....................          { 
....................             banderaOp3=0; 
00B02:  BCF    3F.2
....................             sumaOp3=0; 
00B04:  CLRF   3E
....................             sumaOp3=atof(buffOp3); 
00B06:  CLRF   49
00B08:  MOVLW  38
00B0A:  MOVWF  48
00B0C:  CLRF   4B
00B0E:  CLRF   4A
00B10:  RCALL  068C
00B12:  MOVFF  03,4B
00B16:  MOVFF  02,4A
00B1A:  MOVFF  01,49
00B1E:  MOVFF  00,48
00B22:  RCALL  08BE
00B24:  MOVFF  01,3E
....................          } 
....................       } 
....................        
....................       if(banderaSerial) 
00B28:  BTFSS  1D.0
00B2A:  BRA    0BA6
....................       { 
....................          banderaSerial=0; 
00B2C:  BCF    1D.0
....................          if(banderacadena) 
00B2E:  BTFSS  20.0
00B30:  BRA    0BA6
....................          { 
....................             banderaCadena=0; 
00B32:  BCF    20.0
....................             if(banderaEnter) 
00B34:  BTFSS  1F.0
00B36:  BRA    0BA6
....................             { 
....................                banderaEnter=0; 
00B38:  BCF    1F.0
....................                /////////////////////////////// 
....................                if((sumaOp1&0x0C) > 0x00) 
00B3A:  MOVF   3C,W
00B3C:  ANDLW  0C
00B3E:  BZ    0B44
....................                { 
....................                   banderaPuertoA=1; 
00B40:  BSF    3F.3
....................                } 
00B42:  BRA    0B4E
....................                else if((sumaOp1&0x0C) != 0x0C) 
00B44:  MOVF   3C,W
00B46:  ANDLW  0C
00B48:  SUBLW  0C
00B4A:  BZ    0B4E
....................                { 
....................                   banderaPuertoA=0; 
00B4C:  BCF    3F.3
....................                } 
....................                 
....................                if((sumaOp2&0x11) > 0x00) 
00B4E:  MOVF   3D,W
00B50:  ANDLW  11
00B52:  BZ    0B58
....................                { 
....................                   banderaPuertoB=1; 
00B54:  BSF    3F.4
....................                } 
00B56:  BRA    0B62
....................                else if((sumaOp2&0x11) != 0x11) 
00B58:  MOVF   3D,W
00B5A:  ANDLW  11
00B5C:  SUBLW  11
00B5E:  BZ    0B62
....................                { 
....................                   banderaPuertoB=0; 
00B60:  BCF    3F.4
....................                } 
....................                 
....................                if((sumaOp3&0x42) > 0x00) 
00B62:  MOVF   3E,W
00B64:  ANDLW  42
00B66:  BZ    0B6C
....................                { 
....................                   banderaPuertoD=1; 
00B68:  BSF    3F.5
....................                } 
00B6A:  BRA    0B76
....................                else if((sumaOp3&0x42) != 0x42) 
00B6C:  MOVF   3E,W
00B6E:  ANDLW  42
00B70:  SUBLW  42
00B72:  BZ    0B76
....................                { 
....................                   banderaPuertoD=0; 
00B74:  BCF    3F.5
....................                } 
....................                /////////////////////////////// 
....................  
....................                if((sumaOp1&0x80) > 0x00 && (sumaOp2&0x80) > 0x00 && (sumaOp3&0x80) > 0x00) 
00B76:  MOVF   3C,W
00B78:  ANDLW  80
00B7A:  BZ    0B8C
00B7C:  MOVF   3D,W
00B7E:  ANDLW  80
00B80:  BZ    0B8C
00B82:  MOVF   3E,W
00B84:  ANDLW  80
00B86:  BZ    0B8C
....................                { 
....................                   banderaImprime=1; 
00B88:  BSF    3F.6
....................                } 
00B8A:  BRA    0BA6
....................                else if((sumaOp1&0x80) != 0x80 && (sumaOp2&0x80) != 0x80 && (sumaOp3&0x80) != 0x80) 
00B8C:  MOVF   3C,W
00B8E:  ANDLW  80
00B90:  SUBLW  80
00B92:  BZ    0BA6
00B94:  MOVF   3D,W
00B96:  ANDLW  80
00B98:  SUBLW  80
00B9A:  BZ    0BA6
00B9C:  MOVF   3E,W
00B9E:  ANDLW  80
00BA0:  SUBLW  80
00BA2:  BZ    0BA6
....................                { 
....................                   banderaImprime=0; 
00BA4:  BCF    3F.6
....................                } 
....................             } 
....................          } 
....................       } 
....................        
....................       if(banderaPuertoA) 
00BA6:  BTFSS  3F.3
00BA8:  BRA    0BC2
....................       { 
....................          banderaPuertoA=0; 
00BAA:  BCF    3F.3
....................          if(contador == 1) 
00BAC:  DECFSZ 40,W
00BAE:  BRA    0BBE
....................          { 
....................             contadorA = contadorA << 1; 
00BB0:  BCF    FD8.0
00BB2:  RLCF   42,F
....................             if(contadorA == 128) 
00BB4:  MOVF   42,W
00BB6:  SUBLW  80
00BB8:  BNZ   0BBE
....................             { 
....................                contadorA = 1; 
00BBA:  MOVLW  01
00BBC:  MOVWF  42
....................             } 
....................          } 
....................          output_A(contadorA); 
00BBE:  MOVFF  42,F89
....................       } 
....................       if(banderaPuertoB) 
00BC2:  BTFSS  3F.4
00BC4:  BRA    0BE0
....................       { 
....................          if(contador == 3) 
00BC6:  MOVF   40,W
00BC8:  SUBLW  03
00BCA:  BNZ   0BDC
....................          { 
....................             banderaPuertoB=0; 
00BCC:  BCF    3F.4
....................             contadorB = contadorB << 1; 
00BCE:  BCF    FD8.0
00BD0:  RLCF   43,F
....................             if(contadorB == 128) 
00BD2:  MOVF   43,W
00BD4:  SUBLW  80
00BD6:  BNZ   0BDC
....................             { 
....................                contadorB = 1; 
00BD8:  MOVLW  01
00BDA:  MOVWF  43
....................             } 
....................          } 
....................          output_B(contadorB); 
00BDC:  MOVFF  43,F8A
....................       } 
....................       if(banderaPuertoD) 
00BE0:  BTFSS  3F.5
00BE2:  BRA    0BFE
....................       { 
....................          if(contador == 5) 
00BE4:  MOVF   40,W
00BE6:  SUBLW  05
00BE8:  BNZ   0BFA
....................          { 
....................             banderaPuertoD=0; 
00BEA:  BCF    3F.5
....................             contadorD = contadorD << 1; 
00BEC:  BCF    FD8.0
00BEE:  RLCF   44,F
....................             if(contadorD == 128) 
00BF0:  MOVF   44,W
00BF2:  SUBLW  80
00BF4:  BNZ   0BFA
....................             { 
....................                contadorD = 1; 
00BF6:  MOVLW  01
00BF8:  MOVWF  44
....................             } 
....................          } 
....................          output_D(contadorD); 
00BFA:  MOVFF  44,F8C
....................       } 
....................       if(banderaImprime) 
00BFE:  BTFSS  3F.6
00C00:  BRA    0C16
....................       { 
....................          banderaImprime=0; 
00C02:  BCF    3F.6
....................          printf("El caracter ingresado es: "); 
00C04:  MOVLW  58
00C06:  MOVWF  FF6
00C08:  MOVLW  01
00C0A:  MOVWF  FF7
00C0C:  CALL   0174
....................          putc(buffRx[15-2]); 
00C10:  MOVF   30,W
00C12:  CALL   0196
....................       } 
00C16:  BRA    09BA
....................    } 
.................... } 
00C18:  SLEEP 

Configuration Fuses:
   Word  1: 0100   XT NOFCMEN NOIESO
   Word  2: 1E18   PUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 0500   CCP2C1 NOPBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
