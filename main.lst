CCS PCH C Compiler, Version 5.012, 41559               28-jun.-19 14:42

               Filename:   C:\Users\Usuario\Desktop\ordi\nombre\main.lst

               ROM used:   3086 bytes (5%)
                           Largest free fragment is 62446
               RAM used:   72 (2%) at main() level
                           109 (3%) worst case
               Stack used: 3 locations (2 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   08F8
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  FF2.5
0004A:  GOTO   0054
0004E:  BTFSC  FF2.2
00050:  GOTO   010E
00054:  BTFSS  F9D.5
00056:  GOTO   0060
0005A:  BTFSC  F9E.5
0005C:  GOTO   00A2
00060:  MOVFF  0E,00
00064:  MOVFF  0F,01
00068:  MOVFF  10,02
0006C:  MOVFF  11,03
00070:  MOVFF  0C,FE9
00074:  MOVFF  07,FEA
00078:  BSF    07.7
0007A:  MOVFF  08,FE1
0007E:  MOVFF  09,FE2
00082:  MOVFF  0A,FD9
00086:  MOVFF  0B,FDA
0008A:  MOVFF  12,FF3
0008E:  MOVFF  13,FF4
00092:  MOVFF  14,FFA
00096:  MOVF   04,W
00098:  MOVFF  06,FE0
0009C:  MOVFF  05,FD8
000A0:  RETFIE 0
.................... #include <18f4620.h> 
.................... ///////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
*
0011E:  DATA 49,6E
00120:  DATA 67,72
00122:  DATA 65,73
00124:  DATA 61,20
00126:  DATA 6C,6F
00128:  DATA 73,20
0012A:  DATA 64,61
0012C:  DATA 74,6F
0012E:  DATA 73,20
00130:  DATA 64,65
00132:  DATA 20,6C
00134:  DATA 61,20
00136:  DATA 6D,61
00138:  DATA 6E,65
0013A:  DATA 72,61
0013C:  DATA 3A,20
0013E:  DATA 3E,6F
00140:  DATA 70,31
00142:  DATA 3B,6F
00144:  DATA 70,32
00146:  DATA 3B,6F
00148:  DATA 70,33
0014A:  DATA 3B,63
0014C:  DATA 61,72
0014E:  DATA 61,63
00150:  DATA 74,65
00152:  DATA 72,3C
00154:  DATA 00,00
00156:  DATA 0A,20
00158:  DATA 0D,00
0015A:  DATA 45,6C
0015C:  DATA 20,63
0015E:  DATA 61,72
00160:  DATA 61,63
00162:  DATA 74,65
00164:  DATA 72,20
00166:  DATA 69,6E
00168:  DATA 67,72
0016A:  DATA 65,73
0016C:  DATA 61,64
0016E:  DATA 6F,20
00170:  DATA 65,73
00172:  DATA 3A,20
00174:  DATA 00,00
00176:  TBLRD*+
00178:  MOVF   FF5,F
0017A:  BZ    0196
0017C:  MOVFF  FF6,48
00180:  MOVFF  FF7,49
00184:  MOVF   FF5,W
00186:  BTFSS  F9E.4
00188:  BRA    0186
0018A:  MOVWF  FAD
0018C:  MOVFF  48,FF6
00190:  MOVFF  49,FF7
00194:  BRA    0176
00196:  RETURN 0
*
001A0:  MOVF   57,W
001A2:  BTFSC  FD8.2
001A4:  BRA    0288
001A6:  MOVWF  00
001A8:  MOVF   5B,W
001AA:  BTFSC  FD8.2
001AC:  BRA    0288
001AE:  ADDWF  00,F
001B0:  BNC   01BA
001B2:  MOVLW  81
001B4:  ADDWF  00,F
001B6:  BC    0288
001B8:  BRA    01C2
001BA:  MOVLW  7F
001BC:  SUBWF  00,F
001BE:  BNC   0288
001C0:  BZ    0288
001C2:  MOVFF  58,5F
001C6:  MOVF   5C,W
001C8:  XORWF  5F,F
001CA:  BSF    58.7
001CC:  BSF    5C.7
001CE:  MOVF   5A,W
001D0:  MULWF  5E
001D2:  MOVFF  FF4,61
001D6:  MOVF   59,W
001D8:  MULWF  5D
001DA:  MOVFF  FF4,03
001DE:  MOVFF  FF3,60
001E2:  MULWF  5E
001E4:  MOVF   FF3,W
001E6:  ADDWF  61,F
001E8:  MOVF   FF4,W
001EA:  ADDWFC 60,F
001EC:  MOVLW  00
001EE:  ADDWFC 03,F
001F0:  MOVF   5A,W
001F2:  MULWF  5D
001F4:  MOVF   FF3,W
001F6:  ADDWF  61,F
001F8:  MOVF   FF4,W
001FA:  ADDWFC 60,F
001FC:  MOVLW  00
001FE:  CLRF   02
00200:  ADDWFC 03,F
00202:  ADDWFC 02,F
00204:  MOVF   58,W
00206:  MULWF  5E
00208:  MOVF   FF3,W
0020A:  ADDWF  60,F
0020C:  MOVF   FF4,W
0020E:  ADDWFC 03,F
00210:  MOVLW  00
00212:  ADDWFC 02,F
00214:  MOVF   58,W
00216:  MULWF  5D
00218:  MOVF   FF3,W
0021A:  ADDWF  03,F
0021C:  MOVF   FF4,W
0021E:  ADDWFC 02,F
00220:  MOVLW  00
00222:  CLRF   01
00224:  ADDWFC 01,F
00226:  MOVF   5A,W
00228:  MULWF  5C
0022A:  MOVF   FF3,W
0022C:  ADDWF  60,F
0022E:  MOVF   FF4,W
00230:  ADDWFC 03,F
00232:  MOVLW  00
00234:  ADDWFC 02,F
00236:  ADDWFC 01,F
00238:  MOVF   59,W
0023A:  MULWF  5C
0023C:  MOVF   FF3,W
0023E:  ADDWF  03,F
00240:  MOVF   FF4,W
00242:  ADDWFC 02,F
00244:  MOVLW  00
00246:  ADDWFC 01,F
00248:  MOVF   58,W
0024A:  MULWF  5C
0024C:  MOVF   FF3,W
0024E:  ADDWF  02,F
00250:  MOVF   FF4,W
00252:  ADDWFC 01,F
00254:  INCF   00,F
00256:  BTFSC  01.7
00258:  BRA    0264
0025A:  RLCF   60,F
0025C:  RLCF   03,F
0025E:  RLCF   02,F
00260:  RLCF   01,F
00262:  DECF   00,F
00264:  MOVLW  00
00266:  BTFSS  60.7
00268:  BRA    027E
0026A:  INCF   03,F
0026C:  ADDWFC 02,F
0026E:  ADDWFC 01,F
00270:  MOVF   01,W
00272:  BNZ   027E
00274:  MOVF   02,W
00276:  BNZ   027E
00278:  MOVF   03,W
0027A:  BNZ   027E
0027C:  INCF   00,F
0027E:  BTFSC  5F.7
00280:  BSF    01.7
00282:  BTFSS  5F.7
00284:  BCF    01.7
00286:  BRA    0290
00288:  CLRF   00
0028A:  CLRF   01
0028C:  CLRF   02
0028E:  CLRF   03
00290:  RETURN 0
00292:  MOVLW  8E
00294:  MOVWF  00
00296:  MOVFF  5C,01
0029A:  MOVFF  5B,02
0029E:  CLRF   03
002A0:  MOVF   01,F
002A2:  BNZ   02B6
002A4:  MOVFF  02,01
002A8:  CLRF   02
002AA:  MOVLW  08
002AC:  SUBWF  00,F
002AE:  MOVF   01,F
002B0:  BNZ   02B6
002B2:  CLRF   00
002B4:  BRA    02C6
002B6:  BCF    FD8.0
002B8:  BTFSC  01.7
002BA:  BRA    02C4
002BC:  RLCF   02,F
002BE:  RLCF   01,F
002C0:  DECF   00,F
002C2:  BRA    02B6
002C4:  BCF    01.7
002C6:  RETURN 0
002C8:  MOVF   5B,W
002CA:  BTFSC  FD8.2
002CC:  BRA    0418
002CE:  MOVWF  67
002D0:  MOVF   5F,W
002D2:  BTFSC  FD8.2
002D4:  BRA    0418
002D6:  SUBWF  67,F
002D8:  BNC   02E4
002DA:  MOVLW  7F
002DC:  ADDWF  67,F
002DE:  BTFSC  FD8.0
002E0:  BRA    0418
002E2:  BRA    02F0
002E4:  MOVLW  81
002E6:  SUBWF  67,F
002E8:  BTFSS  FD8.0
002EA:  BRA    0418
002EC:  BTFSC  FD8.2
002EE:  BRA    0418
002F0:  MOVFF  67,00
002F4:  CLRF   01
002F6:  CLRF   02
002F8:  CLRF   03
002FA:  CLRF   66
002FC:  MOVFF  5C,65
00300:  BSF    65.7
00302:  MOVFF  5D,64
00306:  MOVFF  5E,63
0030A:  MOVLW  19
0030C:  MOVWF  67
0030E:  MOVF   62,W
00310:  SUBWF  63,F
00312:  BC    032E
00314:  MOVLW  01
00316:  SUBWF  64,F
00318:  BC    032E
0031A:  SUBWF  65,F
0031C:  BC    032E
0031E:  SUBWF  66,F
00320:  BC    032E
00322:  INCF   66,F
00324:  INCF   65,F
00326:  INCF   64,F
00328:  MOVF   62,W
0032A:  ADDWF  63,F
0032C:  BRA    037E
0032E:  MOVF   61,W
00330:  SUBWF  64,F
00332:  BC    0358
00334:  MOVLW  01
00336:  SUBWF  65,F
00338:  BC    0358
0033A:  SUBWF  66,F
0033C:  BC    0358
0033E:  INCF   66,F
00340:  INCF   65,F
00342:  MOVF   61,W
00344:  ADDWF  64,F
00346:  MOVF   62,W
00348:  ADDWF  63,F
0034A:  BNC   037E
0034C:  INCF   64,F
0034E:  BNZ   037E
00350:  INCF   65,F
00352:  BNZ   037E
00354:  INCF   66,F
00356:  BRA    037E
00358:  MOVF   60,W
0035A:  IORLW  80
0035C:  SUBWF  65,F
0035E:  BC    037C
00360:  MOVLW  01
00362:  SUBWF  66,F
00364:  BC    037C
00366:  INCF   66,F
00368:  MOVF   60,W
0036A:  IORLW  80
0036C:  ADDWF  65,F
0036E:  MOVF   61,W
00370:  ADDWF  64,F
00372:  BNC   0346
00374:  INCF   65,F
00376:  BNZ   0346
00378:  INCF   66,F
0037A:  BRA    0346
0037C:  BSF    03.0
0037E:  DECFSZ 67,F
00380:  BRA    0384
00382:  BRA    039A
00384:  BCF    FD8.0
00386:  RLCF   63,F
00388:  RLCF   64,F
0038A:  RLCF   65,F
0038C:  RLCF   66,F
0038E:  BCF    FD8.0
00390:  RLCF   03,F
00392:  RLCF   02,F
00394:  RLCF   01,F
00396:  RLCF   68,F
00398:  BRA    030E
0039A:  BTFSS  68.0
0039C:  BRA    03AA
0039E:  BCF    FD8.0
003A0:  RRCF   01,F
003A2:  RRCF   02,F
003A4:  RRCF   03,F
003A6:  RRCF   68,F
003A8:  BRA    03AE
003AA:  DECF   00,F
003AC:  BZ    0418
003AE:  BTFSC  68.7
003B0:  BRA    03EE
003B2:  BCF    FD8.0
003B4:  RLCF   63,F
003B6:  RLCF   64,F
003B8:  RLCF   65,F
003BA:  RLCF   66,F
003BC:  MOVF   62,W
003BE:  SUBWF  63,F
003C0:  BC    03D0
003C2:  MOVLW  01
003C4:  SUBWF  64,F
003C6:  BC    03D0
003C8:  SUBWF  65,F
003CA:  BC    03D0
003CC:  SUBWF  66,F
003CE:  BNC   0404
003D0:  MOVF   61,W
003D2:  SUBWF  64,F
003D4:  BC    03E0
003D6:  MOVLW  01
003D8:  SUBWF  65,F
003DA:  BC    03E0
003DC:  SUBWF  66,F
003DE:  BNC   0404
003E0:  MOVF   60,W
003E2:  IORLW  80
003E4:  SUBWF  65,F
003E6:  BC    03EE
003E8:  MOVLW  01
003EA:  SUBWF  66,F
003EC:  BNC   0404
003EE:  INCF   03,F
003F0:  BNZ   0404
003F2:  INCF   02,F
003F4:  BNZ   0404
003F6:  INCF   01,F
003F8:  BNZ   0404
003FA:  INCF   00,F
003FC:  BZ    0418
003FE:  RRCF   01,F
00400:  RRCF   02,F
00402:  RRCF   03,F
00404:  MOVFF  5C,67
00408:  MOVF   60,W
0040A:  XORWF  67,F
0040C:  BTFSS  67.7
0040E:  BRA    0414
00410:  BSF    01.7
00412:  BRA    0420
00414:  BCF    01.7
00416:  BRA    0420
00418:  CLRF   00
0041A:  CLRF   01
0041C:  CLRF   02
0041E:  CLRF   03
00420:  GOTO   078A (RETURN)
00424:  MOVLW  80
00426:  BTFSC  FD8.1
00428:  XORWF  60,F
0042A:  CLRF   65
0042C:  CLRF   66
0042E:  MOVFF  5C,64
00432:  MOVF   60,W
00434:  XORWF  64,F
00436:  MOVF   5B,W
00438:  BTFSC  FD8.2
0043A:  BRA    05F4
0043C:  MOVWF  63
0043E:  MOVWF  00
00440:  MOVF   5F,W
00442:  BTFSC  FD8.2
00444:  BRA    0606
00446:  SUBWF  63,F
00448:  BTFSC  FD8.2
0044A:  BRA    054E
0044C:  BNC   04C8
0044E:  MOVFF  60,69
00452:  BSF    69.7
00454:  MOVFF  61,68
00458:  MOVFF  62,67
0045C:  CLRF   66
0045E:  BCF    FD8.0
00460:  RRCF   69,F
00462:  RRCF   68,F
00464:  RRCF   67,F
00466:  RRCF   66,F
00468:  DECFSZ 63,F
0046A:  BRA    045C
0046C:  BTFSS  64.7
0046E:  BRA    0476
00470:  BSF    65.0
00472:  BRA    062E
00474:  BCF    65.0
00476:  BCF    63.0
00478:  BSF    65.4
0047A:  CLRF   FEA
0047C:  MOVLW  5E
0047E:  MOVWF  FE9
00480:  BRA    0654
00482:  BCF    65.4
00484:  BTFSC  64.7
00486:  BRA    049C
00488:  BTFSS  63.0
0048A:  BRA    04B2
0048C:  RRCF   69,F
0048E:  RRCF   68,F
00490:  RRCF   67,F
00492:  RRCF   66,F
00494:  INCF   00,F
00496:  BTFSC  FD8.2
00498:  BRA    0624
0049A:  BRA    04B2
0049C:  BTFSC  69.7
0049E:  BRA    04B8
004A0:  BCF    FD8.0
004A2:  RLCF   66,F
004A4:  RLCF   67,F
004A6:  RLCF   68,F
004A8:  RLCF   69,F
004AA:  DECF   00,F
004AC:  BTFSC  FD8.2
004AE:  BRA    0624
004B0:  BRA    049C
004B2:  BSF    65.6
004B4:  BRA    058C
004B6:  BCF    65.6
004B8:  MOVFF  5C,64
004BC:  BTFSS  5C.7
004BE:  BRA    04C4
004C0:  BSF    69.7
004C2:  BRA    0616
004C4:  BCF    69.7
004C6:  BRA    0616
004C8:  MOVFF  5F,63
004CC:  MOVFF  5F,00
004D0:  MOVF   5B,W
004D2:  SUBWF  63,F
004D4:  MOVFF  5C,69
004D8:  BSF    69.7
004DA:  MOVFF  5D,68
004DE:  MOVFF  5E,67
004E2:  CLRF   66
004E4:  BCF    FD8.0
004E6:  RRCF   69,F
004E8:  RRCF   68,F
004EA:  RRCF   67,F
004EC:  RRCF   66,F
004EE:  DECFSZ 63,F
004F0:  BRA    04E2
004F2:  BTFSS  64.7
004F4:  BRA    04FC
004F6:  BSF    65.1
004F8:  BRA    062E
004FA:  BCF    65.1
004FC:  BCF    63.0
004FE:  BSF    65.5
00500:  CLRF   FEA
00502:  MOVLW  62
00504:  MOVWF  FE9
00506:  BRA    0654
00508:  BCF    65.5
0050A:  BTFSC  64.7
0050C:  BRA    0522
0050E:  BTFSS  63.0
00510:  BRA    0538
00512:  RRCF   69,F
00514:  RRCF   68,F
00516:  RRCF   67,F
00518:  RRCF   66,F
0051A:  INCF   00,F
0051C:  BTFSC  FD8.2
0051E:  BRA    0624
00520:  BRA    0538
00522:  BTFSC  69.7
00524:  BRA    053E
00526:  BCF    FD8.0
00528:  RLCF   66,F
0052A:  RLCF   67,F
0052C:  RLCF   68,F
0052E:  RLCF   69,F
00530:  DECF   00,F
00532:  BTFSC  FD8.2
00534:  BRA    0624
00536:  BRA    0522
00538:  BSF    65.7
0053A:  BRA    058C
0053C:  BCF    65.7
0053E:  MOVFF  60,64
00542:  BTFSS  60.7
00544:  BRA    054A
00546:  BSF    69.7
00548:  BRA    0616
0054A:  BCF    69.7
0054C:  BRA    0616
0054E:  MOVFF  60,69
00552:  BSF    69.7
00554:  MOVFF  61,68
00558:  MOVFF  62,67
0055C:  BTFSS  64.7
0055E:  BRA    0568
00560:  BCF    69.7
00562:  BSF    65.2
00564:  BRA    062E
00566:  BCF    65.2
00568:  CLRF   66
0056A:  BCF    63.0
0056C:  CLRF   FEA
0056E:  MOVLW  5E
00570:  MOVWF  FE9
00572:  BRA    0654
00574:  BTFSC  64.7
00576:  BRA    05B0
00578:  MOVFF  5C,64
0057C:  BTFSS  63.0
0057E:  BRA    058C
00580:  RRCF   69,F
00582:  RRCF   68,F
00584:  RRCF   67,F
00586:  RRCF   66,F
00588:  INCF   00,F
0058A:  BZ    0624
0058C:  BTFSS  66.7
0058E:  BRA    05A6
00590:  INCF   67,F
00592:  BNZ   05A6
00594:  INCF   68,F
00596:  BNZ   05A6
00598:  INCF   69,F
0059A:  BNZ   05A6
0059C:  RRCF   69,F
0059E:  RRCF   68,F
005A0:  RRCF   67,F
005A2:  INCF   00,F
005A4:  BZ    0624
005A6:  BTFSC  65.6
005A8:  BRA    04B6
005AA:  BTFSC  65.7
005AC:  BRA    053C
005AE:  BRA    05E8
005B0:  MOVLW  80
005B2:  XORWF  69,F
005B4:  BTFSS  69.7
005B6:  BRA    05C0
005B8:  BRA    062E
005BA:  MOVFF  60,64
005BE:  BRA    05D4
005C0:  MOVFF  5C,64
005C4:  MOVF   69,F
005C6:  BNZ   05D4
005C8:  MOVF   68,F
005CA:  BNZ   05D4
005CC:  MOVF   67,F
005CE:  BNZ   05D4
005D0:  CLRF   00
005D2:  BRA    0616
005D4:  BTFSC  69.7
005D6:  BRA    05E8
005D8:  BCF    FD8.0
005DA:  RLCF   66,F
005DC:  RLCF   67,F
005DE:  RLCF   68,F
005E0:  RLCF   69,F
005E2:  DECFSZ 00,F
005E4:  BRA    05D4
005E6:  BRA    0624
005E8:  BTFSS  64.7
005EA:  BRA    05F0
005EC:  BSF    69.7
005EE:  BRA    0616
005F0:  BCF    69.7
005F2:  BRA    0616
005F4:  MOVFF  5F,00
005F8:  MOVFF  60,69
005FC:  MOVFF  61,68
00600:  MOVFF  62,67
00604:  BRA    0616
00606:  MOVFF  5B,00
0060A:  MOVFF  5C,69
0060E:  MOVFF  5D,68
00612:  MOVFF  5E,67
00616:  MOVFF  69,01
0061A:  MOVFF  68,02
0061E:  MOVFF  67,03
00622:  BRA    068C
00624:  CLRF   00
00626:  CLRF   01
00628:  CLRF   02
0062A:  CLRF   03
0062C:  BRA    068C
0062E:  CLRF   66
00630:  COMF   67,F
00632:  COMF   68,F
00634:  COMF   69,F
00636:  COMF   66,F
00638:  INCF   66,F
0063A:  BNZ   0646
0063C:  INCF   67,F
0063E:  BNZ   0646
00640:  INCF   68,F
00642:  BNZ   0646
00644:  INCF   69,F
00646:  BTFSC  65.0
00648:  BRA    0474
0064A:  BTFSC  65.1
0064C:  BRA    04FA
0064E:  BTFSC  65.2
00650:  BRA    0566
00652:  BRA    05BA
00654:  MOVF   FEF,W
00656:  ADDWF  67,F
00658:  BNC   0664
0065A:  INCF   68,F
0065C:  BNZ   0664
0065E:  INCF   69,F
00660:  BTFSC  FD8.2
00662:  BSF    63.0
00664:  MOVF   FED,F
00666:  MOVF   FEF,W
00668:  ADDWF  68,F
0066A:  BNC   0672
0066C:  INCF   69,F
0066E:  BTFSC  FD8.2
00670:  BSF    63.0
00672:  MOVF   FED,F
00674:  MOVF   FEF,W
00676:  BTFSC  FEF.7
00678:  BRA    067C
0067A:  XORLW  80
0067C:  ADDWF  69,F
0067E:  BTFSC  FD8.0
00680:  BSF    63.0
00682:  BTFSC  65.4
00684:  BRA    0482
00686:  BTFSC  65.5
00688:  BRA    0508
0068A:  BRA    0574
0068C:  RETURN 0
*
008C0:  MOVLW  8E
008C2:  MOVWF  00
008C4:  MOVF   48,W
008C6:  SUBWF  00,F
008C8:  MOVFF  49,02
008CC:  MOVFF  4A,01
008D0:  BSF    02.7
008D2:  MOVF   00,F
008D4:  BZ    08E8
008D6:  BCF    FD8.0
008D8:  MOVF   02,F
008DA:  BNZ   08E0
008DC:  MOVF   01,F
008DE:  BZ    08E8
008E0:  RRCF   02,F
008E2:  RRCF   01,F
008E4:  DECFSZ 00,F
008E6:  BRA    08D6
008E8:  BTFSS  49.7
008EA:  BRA    08F6
008EC:  COMF   01,F
008EE:  COMF   02,F
008F0:  INCF   01,F
008F2:  BTFSC  FD8.2
008F4:  INCF   02,F
008F6:  RETURN 0
....................  
.................... #list 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
0068E:  CLRF   4F
00690:  CLRF   4E
00692:  CLRF   4D
00694:  MOVLW  7F
00696:  MOVWF  4C
00698:  CLRF   53
0069A:  CLRF   52
0069C:  CLRF   51
0069E:  CLRF   50
006A0:  BSF    54.0
006A2:  BCF    54.1
006A4:  BCF    54.2
006A6:  CLRF   56
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
006A8:  MOVF   48,W
006AA:  IORWF  49,W
006AC:  BNZ   06B8
....................       return 0; 
006AE:  CLRF   00
006B0:  CLRF   01
006B2:  CLRF   02
006B4:  CLRF   03
006B6:  BRA    08BE
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
006B8:  MOVF   56,W
006BA:  INCF   56,F
006BC:  CLRF   03
006BE:  ADDWF  48,W
006C0:  MOVWF  FE9
006C2:  MOVF   49,W
006C4:  ADDWFC 03,W
006C6:  MOVWF  FEA
006C8:  MOVFF  FEF,55
006CC:  MOVF   55,F
006CE:  BTFSC  FD8.2
006D0:  BRA    0848
....................    { 
....................       if (skip && !isspace(c)) 
006D2:  BTFSS  54.0
006D4:  BRA    06F4
006D6:  MOVF   55,W
006D8:  SUBLW  20
006DA:  BZ    06F4
....................       { 
....................          skip = 0; 
006DC:  BCF    54.0
....................          if (c == '+') 
006DE:  MOVF   55,W
006E0:  SUBLW  2B
006E2:  BNZ   06EA
....................          { 
....................             sign = 0; 
006E4:  BCF    54.1
....................             continue; 
006E6:  BRA    0832
....................          }             
006E8:  BRA    06F4
....................          else if (c == '-') 
006EA:  MOVF   55,W
006EC:  SUBLW  2D
006EE:  BNZ   06F4
....................          { 
....................             sign = 1; 
006F0:  BSF    54.1
....................             continue; 
006F2:  BRA    0832
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
006F4:  BTFSC  54.0
006F6:  BRA    0706
006F8:  MOVF   55,W
006FA:  SUBLW  2E
006FC:  BNZ   0706
006FE:  BTFSC  54.2
00700:  BRA    0706
....................          point = 1; 
00702:  BSF    54.2
00704:  BRA    0832
....................       else if (!skip && isdigit(c)) 
00706:  BTFSC  54.0
00708:  BRA    082C
0070A:  MOVF   55,W
0070C:  SUBLW  2F
0070E:  BTFSC  FD8.0
00710:  BRA    082C
00712:  MOVF   55,W
00714:  SUBLW  39
00716:  BTFSS  FD8.0
00718:  BRA    082C
....................       { 
....................          c -= '0'; 
0071A:  MOVLW  30
0071C:  SUBWF  55,F
....................          if (point) 
0071E:  BTFSS  54.2
00720:  BRA    07C0
....................          { 
....................             pow10 = pow10 * 10.0; 
00722:  MOVFF  4F,5A
00726:  MOVFF  4E,59
0072A:  MOVFF  4D,58
0072E:  MOVFF  4C,57
00732:  CLRF   5E
00734:  CLRF   5D
00736:  MOVLW  20
00738:  MOVWF  5C
0073A:  MOVLW  82
0073C:  MOVWF  5B
0073E:  RCALL  01A0
00740:  MOVFF  03,4F
00744:  MOVFF  02,4E
00748:  MOVFF  01,4D
0074C:  MOVFF  00,4C
....................             result += (float)c / pow10;    
00750:  CLRF   5C
00752:  MOVFF  55,5B
00756:  RCALL  0292
00758:  MOVFF  03,5A
0075C:  MOVFF  02,59
00760:  MOVFF  01,58
00764:  MOVFF  00,57
00768:  MOVFF  03,5E
0076C:  MOVFF  02,5D
00770:  MOVFF  01,5C
00774:  MOVFF  00,5B
00778:  MOVFF  4F,62
0077C:  MOVFF  4E,61
00780:  MOVFF  4D,60
00784:  MOVFF  4C,5F
00788:  BRA    02C8
0078A:  BCF    FD8.1
0078C:  MOVFF  53,5E
00790:  MOVFF  52,5D
00794:  MOVFF  51,5C
00798:  MOVFF  50,5B
0079C:  MOVFF  03,62
007A0:  MOVFF  02,61
007A4:  MOVFF  01,60
007A8:  MOVFF  00,5F
007AC:  RCALL  0424
007AE:  MOVFF  03,53
007B2:  MOVFF  02,52
007B6:  MOVFF  01,51
007BA:  MOVFF  00,50
....................          } 
007BE:  BRA    082A
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
007C0:  CLRF   5A
007C2:  CLRF   59
007C4:  MOVLW  20
007C6:  MOVWF  58
007C8:  MOVLW  82
007CA:  MOVWF  57
007CC:  MOVFF  53,5E
007D0:  MOVFF  52,5D
007D4:  MOVFF  51,5C
007D8:  MOVFF  50,5B
007DC:  RCALL  01A0
007DE:  MOVFF  03,5A
007E2:  MOVFF  02,59
007E6:  MOVFF  01,58
007EA:  MOVFF  00,57
007EE:  CLRF   5C
007F0:  MOVFF  55,5B
007F4:  RCALL  0292
007F6:  BCF    FD8.1
007F8:  MOVFF  5A,5E
007FC:  MOVFF  59,5D
00800:  MOVFF  58,5C
00804:  MOVFF  57,5B
00808:  MOVFF  03,62
0080C:  MOVFF  02,61
00810:  MOVFF  01,60
00814:  MOVFF  00,5F
00818:  RCALL  0424
0081A:  MOVFF  03,53
0081E:  MOVFF  02,52
00822:  MOVFF  01,51
00826:  MOVFF  00,50
....................          } 
....................       } 
0082A:  BRA    0832
....................       else if (!skip) 
0082C:  BTFSC  54.0
0082E:  BRA    0832
....................          break; 
00830:  BRA    0848
00832:  MOVF   56,W
00834:  INCF   56,F
00836:  CLRF   03
00838:  ADDWF  48,W
0083A:  MOVWF  FE9
0083C:  MOVF   49,W
0083E:  ADDWFC 03,W
00840:  MOVWF  FEA
00842:  MOVFF  FEF,55
00846:  BRA    06CC
....................    } 
....................  
....................    if (sign) 
00848:  BTFSS  54.1
0084A:  BRA    087A
....................       result = -1*result; 
0084C:  CLRF   5A
0084E:  CLRF   59
00850:  MOVLW  80
00852:  MOVWF  58
00854:  MOVLW  7F
00856:  MOVWF  57
00858:  MOVFF  53,5E
0085C:  MOVFF  52,5D
00860:  MOVFF  51,5C
00864:  MOVFF  50,5B
00868:  RCALL  01A0
0086A:  MOVFF  03,53
0086E:  MOVFF  02,52
00872:  MOVFF  01,51
00876:  MOVFF  00,50
....................        
....................    if(endptr) 
0087A:  MOVF   4A,W
0087C:  IORWF  4B,W
0087E:  BZ    08AE
....................    { 
....................       if (ptr) { 
00880:  MOVF   56,F
00882:  BZ    089C
....................          ptr--; 
00884:  DECF   56,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
00886:  MOVFF  4A,FE9
0088A:  MOVFF  4B,FEA
0088E:  MOVF   56,W
00890:  ADDWF  48,W
00892:  MOVWF  FEF
00894:  MOVLW  00
00896:  ADDWFC 49,W
00898:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0089A:  BRA    08AE
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0089C:  MOVFF  4A,FE9
008A0:  MOVFF  4B,FEA
008A4:  MOVFF  49,FEC
008A8:  MOVF   FED,F
008AA:  MOVFF  48,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
008AE:  MOVFF  50,00
008B2:  MOVFF  51,01
008B6:  MOVFF  52,02
008BA:  MOVFF  53,03
008BE:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #fuses HS, NOFCMEN, NOIESO, PUT, NOBROWNOUT, NOWDT 
.................... #fuses NOPBADEN, NOMCLR, STVREN, NOLVP, NODEBUG, XT 
.................... #use delay(clock=16000000) 
....................  
.................... #use fast_io(a) 
.................... #use fast_io(b) 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
....................  
.................... #define debugSerial 
....................  
.................... #ifdef debugSerial 
....................    #define TX_232        PIN_C6 
....................    #define RX_232        PIN_C7 
....................    #use RS232(BAUD=9600, XMIT=TX_232, BITS=8,PARITY=N, STOP=1,UART1,RCV=RX_232) 
*
00198:  BTFSS  F9E.4
0019A:  BRA    0198
0019C:  MOVWF  FAD
0019E:  RETURN 0
.................... #endif 
....................  
.................... #define posInicialOp1 2 
.................... #define posInicialOp2 6 
.................... #define posinicialOp3 10 
....................  
.................... #define posFinalOp1 4 
.................... #define posFinalOp2 8 
.................... #define posFinalOp3 12 
....................  
.................... #define posCaracter 14  
....................  
.................... char caracter; 
.................... char bandera; 
.................... char echo; 
.................... char enter; 
.................... char cadena; 
.................... char puntoComa; 
.................... char convierte; 
....................  
.................... char buffRx[15]={}; 
.................... char buffOp1[3]={}; 
.................... char buffOp2[3]={}; 
.................... char buffOp3[3]={}; 
....................  
.................... int indexBff=0; 
.................... int sumaOp1=0; 
.................... int sumaOp2=0; 
.................... int sumaOp3=0; 
....................  
.................... int1 banderaOp1=0; 
.................... int1 banderaOp2=0; 
.................... int1 banderaOp3=0; 
....................  
.................... int1 banderaPuertoA=0; 
.................... int1 banderaPuertoB=0; 
.................... int1 banderaPuertoD=0; 
.................... int1 banderaImprime=0; 
....................  
.................... int contador=0; 
.................... int contadorPuntoComa=0; 
....................  
.................... int contadorA=1; 
.................... int contadorB=1; 
.................... int contadorD=1; 
....................  
.................... #bit banderaSerial = bandera.0 
.................... #bit banderaEcho = echo.0 
.................... #bit banderaEnter = enter.0 
.................... #bit banderaCadena = cadena.0  
.................... #bit banderaPuntoComa = puntoComa.0 
.................... #bit banderaConvierte = convierte.0 
....................  
.................... #INT_RDA 
.................... void itrRDA(void) 
.................... { 
....................    caracter = getc(); 
*
000A2:  BTFSS  F9E.5
000A4:  BRA    00A2
000A6:  MOVFF  FAE,1C
....................    BuffRx[indexBff]=caracter; 
000AA:  CLRF   03
000AC:  MOVF   3B,W
000AE:  ADDLW  23
000B0:  MOVWF  FE9
000B2:  MOVLW  00
000B4:  ADDWFC 03,W
000B6:  MOVWF  FEA
000B8:  MOVFF  1C,FEF
....................    indexBff++; 
000BC:  INCF   3B,F
....................    banderaEcho = 1; 
000BE:  BSF    1E.0
....................    banderaSerial = 1; 
000C0:  BSF    1D.0
....................     
....................    if(caracter==0x0D) 
000C2:  MOVF   1C,W
000C4:  SUBLW  0D
000C6:  BNZ   00CA
....................    { 
....................       banderaEnter=1; 
000C8:  BSF    1F.0
....................    } 
....................    if (indexBff == 15) 
000CA:  MOVF   3B,W
000CC:  SUBLW  0F
000CE:  BNZ   00D2
....................    { 
....................       indexBff = 0; 
000D0:  CLRF   3B
....................    } 
....................    if(buffRx[0] == 0x3E && buffRx[indexBff-2] == 0x3C) 
000D2:  MOVF   23,W
000D4:  SUBLW  3E
000D6:  BNZ   00F0
000D8:  MOVLW  02
000DA:  SUBWF  3B,W
000DC:  CLRF   03
000DE:  ADDLW  23
000E0:  MOVWF  FE9
000E2:  MOVLW  00
000E4:  ADDWFC 03,W
000E6:  MOVWF  FEA
000E8:  MOVF   FEF,W
000EA:  SUBLW  3C
000EC:  BNZ   00F0
....................    { 
....................       banderaCadena = 1; 
000EE:  BSF    20.0
....................    } 
....................    if(buffRx[indexBff] == 0x3B) 
000F0:  CLRF   03
000F2:  MOVF   3B,W
000F4:  ADDLW  23
000F6:  MOVWF  FE9
000F8:  MOVLW  00
000FA:  ADDWFC 03,W
000FC:  MOVWF  FEA
000FE:  MOVF   FEF,W
00100:  SUBLW  3B
00102:  BNZ   0108
....................    { 
....................       banderaPuntoComa = 1; 
00104:  BSF    21.0
....................       contadorPuntoComa++; 
00106:  INCF   41,F
....................    } 
.................... } 
....................  
00108:  BCF    F9E.5
0010A:  GOTO   0060
.................... #int_timer0 
.................... void timer_0() 
.................... { 
....................    set_timer0(15536); 
0010E:  MOVLW  3C
00110:  MOVWF  FD7
00112:  MOVLW  B0
00114:  MOVWF  FD6
....................    contador++; 
00116:  INCF   40,F
00118:  BCF    FF2.2
0011A:  GOTO   0060
.................... } 
....................  
.................... void main(void) 
*
008F8:  CLRF   FF8
008FA:  BCF    FD0.7
008FC:  BSF    07.7
008FE:  BSF    FB8.3
00900:  MOVLW  A0
00902:  MOVWF  FAF
00904:  MOVLW  01
00906:  MOVWF  FB0
00908:  MOVLW  A6
0090A:  MOVWF  FAC
0090C:  MOVLW  90
0090E:  MOVWF  FAB
00910:  CLRF   3B
00912:  CLRF   3C
00914:  CLRF   3D
00916:  CLRF   3E
00918:  BCF    3F.0
0091A:  BCF    3F.1
0091C:  BCF    3F.2
0091E:  BCF    3F.3
00920:  BCF    3F.4
00922:  BCF    3F.5
00924:  BCF    3F.6
00926:  CLRF   40
00928:  CLRF   41
0092A:  MOVLW  01
0092C:  MOVWF  42
0092E:  MOVWF  43
00930:  MOVWF  44
00932:  MOVF   FC1,W
00934:  ANDLW  C0
00936:  IORLW  0F
00938:  MOVWF  FC1
0093A:  MOVLW  07
0093C:  MOVWF  FB4
0093E:  BRA    094A
00940:  DATA 02,00
00942:  DATA 16,00
00944:  DATA 00,18
00946:  DATA 40,23
00948:  DATA 00,00
0094A:  MOVLW  00
0094C:  MOVWF  FF8
0094E:  MOVLW  09
00950:  MOVWF  FF7
00952:  MOVLW  40
00954:  MOVWF  FF6
00956:  TBLRD*+
00958:  MOVF   FF5,W
0095A:  MOVWF  00
0095C:  XORLW  00
0095E:  BZ    0986
00960:  TBLRD*+
00962:  MOVF   FF5,W
00964:  MOVWF  01
00966:  BTFSC  FE8.7
00968:  BRA    0974
0096A:  ANDLW  0F
0096C:  MOVWF  FEA
0096E:  TBLRD*+
00970:  MOVFF  FF5,FE9
00974:  BTFSC  01.6
00976:  TBLRD*+
00978:  BTFSS  01.6
0097A:  TBLRD*+
0097C:  MOVFF  FF5,FEE
00980:  DCFSNZ 00,F
00982:  BRA    0956
00984:  BRA    0978
00986:  CLRF   FF8
.................... { 
....................    set_tris_a(0x00); 
00988:  MOVLW  00
0098A:  MOVWF  F92
....................    set_tris_b(0x00); 
0098C:  MOVWF  F93
....................    set_tris_c(0x80); 
0098E:  MOVLW  80
00990:  MOVWF  F94
....................    set_tris_d(0x00); 
00992:  MOVLW  00
00994:  MOVWF  F95
....................     
....................    setup_timer_0(rtcc_internal | rtcc_div_8); 
00996:  MOVLW  82
00998:  MOVWF  FD5
....................    set_timer0(15536); 
0099A:  MOVLW  3C
0099C:  MOVWF  FD7
0099E:  MOVLW  B0
009A0:  MOVWF  FD6
....................      
....................    enable_interrupts(int_timer0); 
009A2:  BSF    FF2.5
....................    enable_interrupts(global);    
009A4:  MOVLW  C0
009A6:  IORWF  FF2,F
....................    enable_interrupts(INT_RDA); 
009A8:  BSF    F9D.5
....................     
....................    printf("Ingresa los datos de la manera: >op1;op2;op3;caracter<"); 
009AA:  MOVLW  1E
009AC:  MOVWF  FF6
009AE:  MOVLW  01
009B0:  MOVWF  FF7
009B2:  CALL   0176
....................    printf("\n \r"); 
009B6:  MOVLW  56
009B8:  MOVWF  FF6
009BA:  MOVLW  01
009BC:  MOVWF  FF7
009BE:  CALL   0176
....................     
....................    while(TRUE) 
....................    { 
....................       if(banderaEcho) 
009C2:  BTFSS  1E.0
009C4:  BRA    09CE
....................       { 
....................          putc(caracter); 
009C6:  MOVF   1C,W
009C8:  CALL   0198
....................          banderaEcho = 0; 
009CC:  BCF    1E.0
....................       } 
....................        
....................       if(banderaPuntoComa) 
009CE:  BTFSS  21.0
009D0:  BRA    0AAA
....................       { 
....................          banderaPuntoComa=0; 
009D2:  BCF    21.0
....................          if(contadorPuntoComa==1) 
009D4:  DECFSZ 41,W
009D6:  BRA    0A1A
....................          { 
....................             banderaOp1=1; 
009D8:  BSF    3F.0
....................             for(int index = posInicialOp1; index <= posFinalOp1; index++) 
009DA:  MOVLW  02
009DC:  MOVWF  45
009DE:  MOVF   45,W
009E0:  SUBLW  04
009E2:  BNC   0A18
....................             { 
....................                buffOp1[index] = buffRx[index]; 
009E4:  CLRF   03
009E6:  MOVF   45,W
009E8:  ADDLW  32
009EA:  MOVWF  01
009EC:  MOVLW  00
009EE:  ADDWFC 03,F
009F0:  MOVFF  03,49
009F4:  CLRF   03
009F6:  MOVF   45,W
009F8:  ADDLW  23
009FA:  MOVWF  FE9
009FC:  MOVLW  00
009FE:  ADDWFC 03,W
00A00:  MOVWF  FEA
00A02:  MOVFF  FEF,4A
00A06:  MOVFF  49,FEA
00A0A:  MOVFF  01,FE9
00A0E:  MOVFF  4A,FEF
....................                banderaConvierte=1; 
00A12:  BSF    22.0
00A14:  INCF   45,F
00A16:  BRA    09DE
....................             } 
....................          } 
00A18:  BRA    0AAA
....................          else if(contadorPuntoComa==2) 
00A1A:  MOVF   41,W
00A1C:  SUBLW  02
00A1E:  BNZ   0A62
....................          { 
....................             banderaOp2=1; 
00A20:  BSF    3F.1
....................             for(int index = posInicialOp2; index <= posFinalOp2; index++) 
00A22:  MOVLW  06
00A24:  MOVWF  46
00A26:  MOVF   46,W
00A28:  SUBLW  08
00A2A:  BNC   0A60
....................             { 
....................                buffOp2[index] = buffRx[index]; 
00A2C:  CLRF   03
00A2E:  MOVF   46,W
00A30:  ADDLW  35
00A32:  MOVWF  01
00A34:  MOVLW  00
00A36:  ADDWFC 03,F
00A38:  MOVFF  03,49
00A3C:  CLRF   03
00A3E:  MOVF   46,W
00A40:  ADDLW  23
00A42:  MOVWF  FE9
00A44:  MOVLW  00
00A46:  ADDWFC 03,W
00A48:  MOVWF  FEA
00A4A:  MOVFF  FEF,4A
00A4E:  MOVFF  49,FEA
00A52:  MOVFF  01,FE9
00A56:  MOVFF  4A,FEF
....................                banderaConvierte=1; 
00A5A:  BSF    22.0
00A5C:  INCF   46,F
00A5E:  BRA    0A26
....................             } 
....................          }          
00A60:  BRA    0AAA
....................          else if(contadorPuntoComa==3) 
00A62:  MOVF   41,W
00A64:  SUBLW  03
00A66:  BNZ   0AAA
....................          { 
....................             contadorPuntoComa=0; 
00A68:  CLRF   41
....................             banderaOp3=1; 
00A6A:  BSF    3F.2
....................             for(int index = posInicialOp3; index <= posFinalOp3; index++) 
00A6C:  MOVLW  0A
00A6E:  MOVWF  47
00A70:  MOVF   47,W
00A72:  SUBLW  0C
00A74:  BNC   0AAA
....................             { 
....................                buffOp3[index] = buffRx[index]; 
00A76:  CLRF   03
00A78:  MOVF   47,W
00A7A:  ADDLW  38
00A7C:  MOVWF  01
00A7E:  MOVLW  00
00A80:  ADDWFC 03,F
00A82:  MOVFF  03,49
00A86:  CLRF   03
00A88:  MOVF   47,W
00A8A:  ADDLW  23
00A8C:  MOVWF  FE9
00A8E:  MOVLW  00
00A90:  ADDWFC 03,W
00A92:  MOVWF  FEA
00A94:  MOVFF  FEF,4A
00A98:  MOVFF  49,FEA
00A9C:  MOVFF  01,FE9
00AA0:  MOVFF  4A,FEF
....................                banderaConvierte=1; 
00AA4:  BSF    22.0
00AA6:  INCF   47,F
00AA8:  BRA    0A70
....................             } 
....................          } 
....................       } 
....................        
....................       if(banderaConvierte) 
00AAA:  BTFSS  22.0
00AAC:  BRA    0B30
....................       { 
....................          if(banderaOp1) 
00AAE:  BTFSS  3F.0
00AB0:  BRA    0ADA
....................          { 
....................             banderaOp1=0; 
00AB2:  BCF    3F.0
....................             sumaOp1=0; 
00AB4:  CLRF   3C
....................             sumaOp1=atof(buffOp1); 
00AB6:  CLRF   49
00AB8:  MOVLW  32
00ABA:  MOVWF  48
00ABC:  CLRF   4B
00ABE:  CLRF   4A
00AC0:  RCALL  068E
00AC2:  MOVFF  03,4B
00AC6:  MOVFF  02,4A
00ACA:  MOVFF  01,49
00ACE:  MOVFF  00,48
00AD2:  RCALL  08C0
00AD4:  MOVFF  01,3C
....................          } 
00AD8:  BRA    0B30
....................          else if(banderaOp2) 
00ADA:  BTFSS  3F.1
00ADC:  BRA    0B06
....................          { 
....................             banderaOp2=0; 
00ADE:  BCF    3F.1
....................             sumaOp2=0; 
00AE0:  CLRF   3D
....................             sumaOp2=atof(buffOp2); 
00AE2:  CLRF   49
00AE4:  MOVLW  35
00AE6:  MOVWF  48
00AE8:  CLRF   4B
00AEA:  CLRF   4A
00AEC:  RCALL  068E
00AEE:  MOVFF  03,4B
00AF2:  MOVFF  02,4A
00AF6:  MOVFF  01,49
00AFA:  MOVFF  00,48
00AFE:  RCALL  08C0
00B00:  MOVFF  01,3D
....................          } 
00B04:  BRA    0B30
....................          else if(banderaOp3) 
00B06:  BTFSS  3F.2
00B08:  BRA    0B30
....................          { 
....................             banderaOp3=0; 
00B0A:  BCF    3F.2
....................             sumaOp3=0; 
00B0C:  CLRF   3E
....................             sumaOp3=atof(buffOp3); 
00B0E:  CLRF   49
00B10:  MOVLW  38
00B12:  MOVWF  48
00B14:  CLRF   4B
00B16:  CLRF   4A
00B18:  RCALL  068E
00B1A:  MOVFF  03,4B
00B1E:  MOVFF  02,4A
00B22:  MOVFF  01,49
00B26:  MOVFF  00,48
00B2A:  RCALL  08C0
00B2C:  MOVFF  01,3E
....................          } 
....................       } 
....................        
....................       if(banderaSerial) 
00B30:  BTFSS  1D.0
00B32:  BRA    0BAE
....................       { 
....................          banderaSerial=0; 
00B34:  BCF    1D.0
....................          if(banderacadena) 
00B36:  BTFSS  20.0
00B38:  BRA    0BAE
....................          { 
....................             banderaCadena=0; 
00B3A:  BCF    20.0
....................             if(banderaEnter) 
00B3C:  BTFSS  1F.0
00B3E:  BRA    0BAE
....................             { 
....................                banderaEnter=0; 
00B40:  BCF    1F.0
....................                /////////////////////////////// 
....................                if((sumaOp1&0x0C) > 0x00) 
00B42:  MOVF   3C,W
00B44:  ANDLW  0C
00B46:  BZ    0B4C
....................                { 
....................                   banderaPuertoA=1; 
00B48:  BSF    3F.3
....................                } 
00B4A:  BRA    0B56
....................                else if((sumaOp1&0x0C) != 0x0C) 
00B4C:  MOVF   3C,W
00B4E:  ANDLW  0C
00B50:  SUBLW  0C
00B52:  BZ    0B56
....................                { 
....................                   banderaPuertoA=0; 
00B54:  BCF    3F.3
....................                } 
....................                 
....................                if((sumaOp2&0x11) > 0x00) 
00B56:  MOVF   3D,W
00B58:  ANDLW  11
00B5A:  BZ    0B60
....................                { 
....................                   banderaPuertoB=1; 
00B5C:  BSF    3F.4
....................                } 
00B5E:  BRA    0B6A
....................                else if((sumaOp2&0x11) != 0x11) 
00B60:  MOVF   3D,W
00B62:  ANDLW  11
00B64:  SUBLW  11
00B66:  BZ    0B6A
....................                { 
....................                   banderaPuertoB=0; 
00B68:  BCF    3F.4
....................                } 
....................                 
....................                if((sumaOp3&0x42) > 0x00) 
00B6A:  MOVF   3E,W
00B6C:  ANDLW  42
00B6E:  BZ    0B74
....................                { 
....................                   banderaPuertoD=1; 
00B70:  BSF    3F.5
....................                } 
00B72:  BRA    0B7E
....................                else if((sumaOp3&0x42) != 0x42) 
00B74:  MOVF   3E,W
00B76:  ANDLW  42
00B78:  SUBLW  42
00B7A:  BZ    0B7E
....................                { 
....................                   banderaPuertoD=0; 
00B7C:  BCF    3F.5
....................                } 
....................                /////////////////////////////// 
....................  
....................                /////////////////////////////// 
....................                if((sumaOp1&0x80) > 0x00 && (sumaOp2&0x80) > 0x00 && (sumaOp3&0x80) > 0x00) 
00B7E:  MOVF   3C,W
00B80:  ANDLW  80
00B82:  BZ    0B94
00B84:  MOVF   3D,W
00B86:  ANDLW  80
00B88:  BZ    0B94
00B8A:  MOVF   3E,W
00B8C:  ANDLW  80
00B8E:  BZ    0B94
....................                { 
....................                   banderaImprime=1; 
00B90:  BSF    3F.6
....................                } 
00B92:  BRA    0BAE
....................                else if((sumaOp1&0x80) != 0x80 && (sumaOp2&0x80) != 0x80 && (sumaOp3&0x80) != 0x80) 
00B94:  MOVF   3C,W
00B96:  ANDLW  80
00B98:  SUBLW  80
00B9A:  BZ    0BAE
00B9C:  MOVF   3D,W
00B9E:  ANDLW  80
00BA0:  SUBLW  80
00BA2:  BZ    0BAE
00BA4:  MOVF   3E,W
00BA6:  ANDLW  80
00BA8:  SUBLW  80
00BAA:  BZ    0BAE
....................                { 
....................                   banderaImprime=0; 
00BAC:  BCF    3F.6
....................                } 
....................             } 
....................          } 
....................       } 
....................        
....................       if(banderaPuertoA) 
00BAE:  BTFSS  3F.3
00BB0:  BRA    0BC6
....................       { 
....................          banderaPuertoA=0; 
00BB2:  BCF    3F.3
....................          contadorA = contadorA << 1; 
00BB4:  BCF    FD8.0
00BB6:  RLCF   42,F
....................          if(contadorA == 128) 
00BB8:  MOVF   42,W
00BBA:  SUBLW  80
00BBC:  BNZ   0BC2
....................          { 
....................             contadorA = 1; 
00BBE:  MOVLW  01
00BC0:  MOVWF  42
....................          } 
....................          output_A(contadorA); 
00BC2:  MOVFF  42,F89
....................       } 
....................       if(banderaPuertoB) 
00BC6:  BTFSS  3F.4
00BC8:  BRA    0BDE
....................       { 
....................          banderaPuertoB=0; 
00BCA:  BCF    3F.4
....................          contadorB = contadorB << 1; 
00BCC:  BCF    FD8.0
00BCE:  RLCF   43,F
....................          if(contadorB == 128) 
00BD0:  MOVF   43,W
00BD2:  SUBLW  80
00BD4:  BNZ   0BDA
....................          { 
....................             contadorB = 1; 
00BD6:  MOVLW  01
00BD8:  MOVWF  43
....................          } 
....................          output_B(contadorB); 
00BDA:  MOVFF  43,F8A
....................       } 
....................       if(banderaPuertoD) 
00BDE:  BTFSS  3F.5
00BE0:  BRA    0BF6
....................       { 
....................          banderaPuertoD=0; 
00BE2:  BCF    3F.5
....................          contadorD = contadorD << 1; 
00BE4:  BCF    FD8.0
00BE6:  RLCF   44,F
....................          if(contadorD == 128) 
00BE8:  MOVF   44,W
00BEA:  SUBLW  80
00BEC:  BNZ   0BF2
....................          { 
....................             contadorD = 1; 
00BEE:  MOVLW  01
00BF0:  MOVWF  44
....................          } 
....................          output_D(contadorD); 
00BF2:  MOVFF  44,F8C
....................       } 
....................       if(banderaImprime) 
00BF6:  BTFSS  3F.6
00BF8:  BRA    0C0E
....................       { 
....................          banderaImprime=0; 
00BFA:  BCF    3F.6
....................          printf("El caracter ingresado es: "); 
00BFC:  MOVLW  5A
00BFE:  MOVWF  FF6
00C00:  MOVLW  01
00C02:  MOVWF  FF7
00C04:  CALL   0176
....................          putc(buffRx[15-2]); 
00C08:  MOVF   30,W
00C0A:  CALL   0198
....................       } 
00C0E:  BRA    09C2
....................    } 
.................... } 
00C10:  SLEEP 

Configuration Fuses:
   Word  1: 0100   XT NOFCMEN NOIESO
   Word  2: 1E18   PUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 0500   CCP2C1 NOPBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
